/****************************************************************************
 *                                                                          *
 * Copyrightc++	 1999 MathEngine Canada, Inc.                               *
 * All Rights Reserved.                                                     *
 *                                                                          *
 * This is the UNPUBLISHED, PROPRIETARY and CONFIDENTIAL source code of     *
 * MathEngine Canada Inc. The contents of this file may not be disclosed to *
 * third parties, copied or duplicated in any form, in whole or in part,    *
 * without the prior written permission of MathEngine Canada Inc.           *
 *                                                                          *
 * Project Name: Kea Dynamics Library.                                      *
 * Authors: Russell Smith.                                                  *
 *          Richard Tonge						    *
 *          Bill Gallafent                                                  *
 *                                                                          *
 ****************************************************************************/

/*

"It all comes from here, the stench and the fear."

*/

#include <stdio.h>
#include <math.h>
#include <string.h>
#include "keaStuff.hpp"
#include "keaMathStuff.hpp"
#include "keaLCP.hpp"
#include "keaInternal.hpp"
#include "keaProfile.hpp"
#include "keaMatrix.hpp"
#include "MdtKea.h"
#include <eetypes.h>  // for booleans

//*** dodgy hacks for testing

static int number = 0;
extern int fr;
int f=0;

//*** memory pool management

void* poolstack[3];
int   poolstack_ptr;
void* pool_ptr; // The address of the next free address in the pool
void* pool_max; // The address of the end of the pool

//****************************************
//A function the user can call to find out how big a memory pool they should give us
//****************************************

int MdtKeaMemoryRequired(int* rows_in_partition,int num_partitions)
{
    int max_rows=0;
    int i;
    for(i=0;i!=num_partitions;i++) {if (rows_in_partition[i]>max_rows) max_rows=rows_in_partition[i];}
    int c4size=ceil4(max_rows);
    
    int jvectorstore  =8*c4size/4*24*4; //printf("%d\n",jvectorstore); 
    int jmvectorstore =8*c4size/4*24*4; //printf("%d\n",jmvectorstore);
    int A             =c4size*c4size*4; //printf("%d\n",A);
    int Ainv          =c4size*c4size*4; //printf("%d\n",Ainv);
    int LCPdx         =c4size*c4size*4; //printf("%d\n",LCPdx);
    int LCPQ          =c4size*c4size*4; //printf("%d\n",LCPQ);
    
    return jvectorstore+jmvectorstore+A+Ainv+LCPdx+LCPQ; 
}

//**************************************
// Stuff used by the j stripper jump table

//** Worst case is four 1 line constraints, each referencing 2 bodies 
#define MAXPERROW (8)

void nocross01    (int *offset,int conssize,int b1present,MeReal **Jp,MeReal **JMp,MeReal **Jbase, MeReal **JMbase, 
                   MeReal **pJsrc,
                   MdtKeaBody *body0,
                   MdtKeaBody *body1,MeReal *body0invI,MeReal *body1invI) 
{   //printf("nocross     ");
    //printf("0 1 ",conssize);
    *offset=(*offset)+conssize;
}
void nocross02    (int *offset,int conssize,int b1present,MeReal **Jp,MeReal **JMp,MeReal **Jbase, MeReal **JMbase, 
                   MeReal **pJsrc,MdtKeaBody *body0,MdtKeaBody *body1,float *body0invI,float *body1invI) 
{   //printf("nocross     ");
    //printf("0 2 ",conssize);
    *offset=(*offset)+conssize;
}
void nocross03    (int *offset,int conssize,int b1present,MeReal **Jp,MeReal **JMp,MeReal **Jbase, MeReal **JMbase,
                   MeReal **pJsrc,MdtKeaBody *body0,MdtKeaBody *body1,float *body0invI,float *body1invI) 
{   //printf("nocross     ");
    //printf("0 3 ",conssize);
    *offset=(*offset)+conssize;
}
void nocross11    (int *offset,int conssize,int b1present,MeReal **Jp,MeReal **JMp,MeReal **Jbase, MeReal **JMbase, 
                   MeReal **pJsrc,MdtKeaBody *body0,MdtKeaBody *body1,float *body0invI,float *body1invI) 
{   //printf("nocross     ");
    //printf("1 2 ",conssize);
    *offset=(*offset)+conssize;
}
void nocross12    (int *offset,int conssize,int b1present,MeReal **Jp,MeReal **JMp,MeReal **Jbase, MeReal **JMbase, 
                   MeReal **pJsrc,MdtKeaBody *body0,MdtKeaBody *body1,float *body0invI,float *body1invI) 
{   //printf("nocross     ");
    //printf("1 3 ",conssize);
    *offset=(*offset)+conssize;
}
void nocross21    (int *offset,int conssize,int b1present,MeReal **Jp,MeReal **JMp,MeReal **Jbase, MeReal **JMbase, 
                   MeReal **pJsrc,MdtKeaBody *body0,MdtKeaBody *body1,float *body0invI,float *body1invI) 
{   //printf("nocross     ");
    //printf("2 3 ",conssize);
    *offset=(*offset)+conssize;
}

void nocrossinc04 (int *offset,int conssize,int b1present,MeReal **pJp,MeReal **pJMp,MeReal **pJbase, MeReal **pJMbase,
                   MeReal **pJsrc,MdtKeaBody *body0,MdtKeaBody *body1,float *body0invI,float *body1invI) 
{   
    //printf("0 4 | ");
    MeReal *Jp=*pJp;
    MeReal *JMp=*pJMp;

    //** Store J and JM for body 0
    __asm__ __volatile__("
    sqc2 vf1,0x00(%0)
    sqc2 vf2,0x10(%0)
    sqc2 vf3,0x20(%0)
    sqc2 vf4,0x30(%0)
    sqc2 vf5,0x40(%0)
    sqc2 vf6,0x50(%0)
    sqc2 vf13,0x00(%1)
    sqc2 vf14,0x10(%1)
    sqc2 vf15,0x20(%1)
    sqc2 vf16,0x30(%1)
    sqc2 vf17,0x40(%1)
    sqc2 vf18,0x50(%1)
    " : : "r" (&Jp[0]) , "r" (&JMp[0]));

    if(b1present)
    {
    //** Store J and JM for body 1
    __asm__ __volatile__("
    sqc2 vf7,0x00(%0)
    sqc2 vf8,0x10(%0)
    sqc2 vf9,0x20(%0)
    sqc2 vf10,0x30(%0)
    sqc2 vf11,0x40(%0)
    sqc2 vf12,0x50(%0)
    sqc2 vf19,0x00(%1)
    sqc2 vf20,0x10(%1)
    sqc2 vf21,0x20(%1)
    sqc2 vf22,0x30(%1)
    sqc2 vf23,0x40(%1)
    sqc2 vf24,0x50(%1)
    " : : "r" (&Jp[24]) , "r" (&JMp[24]));    
    }
    *offset=0;
    //*stripnum=(*stripnum)+1;
    
    //** Increment Jp,JMp
    *pJbase=(*pJbase)+MAXPERROW*24;
    *pJMbase=(*pJMbase)+MAXPERROW*24;
    *pJp=*pJbase;
    *pJMp=*pJMbase;

    __asm__ __volatile__("
    __expression_asm
    Body0Jcol0
    Body0Jcol1
    Body0Jcol2
    Body0Jcol3
    Body0Jcol4
    Body0Jcol5
    Body1Jcol0
    Body1Jcol1
    Body1Jcol2
    Body1Jcol3
    Body1Jcol4
    Body1Jcol5
    
    'lqc2 @Body0Jcol0,0x00(%0)
    'lqc2 @Body0Jcol1,0x10(%0)
    'lqc2 @Body0Jcol2,0x20(%0)
    'lqc2 @Body0Jcol3,0x30(%0)
    'lqc2 @Body0Jcol4,0x40(%0)
    'lqc2 @Body0Jcol5,0x50(%0)
    'lqc2 @Body1Jcol0,0x60(%0)
    'lqc2 @Body1Jcol1,0x70(%0)
    'lqc2 @Body1Jcol2,0x80(%0)
    'lqc2 @Body1Jcol3,0x90(%0)
    'lqc2 @Body1Jcol4,0xa0(%0)
    'lqc2 @Body1Jcol5,0xb0(%0)

    ~Body0Jcol0
    ~Body0Jcol1
    ~Body0Jcol2
    ~Body0Jcol3
    ~Body0Jcol4
    ~Body0Jcol5
    ~Body1Jcol0
    ~Body1Jcol1
    ~Body1Jcol2
    ~Body1Jcol3
    ~Body1Jcol4
    ~Body1Jcol5
 
    __end_expression_asm
    " : : "r" (&Jp[0]));

}
void nocrossinc13 (int *offset,int conssize,int b1present,MeReal **Jp,MeReal **JMp,MeReal **Jbase, MeReal **JMbase,
                   MeReal **pJsrc,MdtKeaBody *body0,MdtKeaBody *body1,float *body0invI,float *body1invI) 
{   //printf("nocrossinc  ");
    //printf("1 4 | ",conssize);
    *offset=0;
    //*stripnum=(*stripnum)+1;
}
void nocrossinc22 (int *offset,int conssize,int b1present,MeReal **Jp,MeReal **JMp,MeReal **Jbase, MeReal **JMbase, 
                   MeReal **pJsrc,MdtKeaBody *body0,MdtKeaBody *body1,float *body0invI,float *body1invI) 
{   //printf("nocrossinc  ");
    //printf("2 2 | ",conssize);
    *offset=0;
    //*stripnum=(*stripnum)+1;
}
void nocrossinc31 (int *offset,int conssize,int b1present,MeReal **Jp,MeReal **JMp,MeReal **Jbase, MeReal **JMbase, 
                   MeReal **pJsrc,MdtKeaBody *body0,MdtKeaBody *body1,float *body0invI,float *body1invI) 
{   //printf("nocrossinc  ");
    //printf("3 4 | ",conssize);
    *offset=0;
    //*stripnum=(*stripnum)+1;
}

void crossone05   (int *offset,int conssize,int b1present,MeReal **Jp,MeReal **JMp,MeReal **Jbase, MeReal **JMbase, 
                   MeReal **pJsrc,MdtKeaBody *body0,MdtKeaBody *body1,float *body0invI,float *body1invI) 
{   //printf("crossone    ");
    //printf("0 4 | 0 1 ",4-(*offset),(*offset)+conssize-4);
    *offset=(*offset)+conssize-4;
    //*stripnum=(*stripnum)+1;
}
void crossone06   (int *offset,int conssize,int b1present,MeReal **pJdest,MeReal **pJMdest,MeReal **pJbase, MeReal **pJMbase,
                   MeReal **pJsrc,MdtKeaBody *body0,MdtKeaBody *body1,float *body0invI,float *body1invI) 
{   
    MeReal *Jsrc=*pJsrc;
    //printf("0 4 | 0 2 ");

    //** Store J and JM for body 0
    __asm__ __volatile__("
    sqc2 vf01,0x00(%0);sqc2 vf02,0x10(%0);sqc2 vf03,0x20(%0);sqc2 vf04,0x30(%0);sqc2 vf05,0x40(%0);sqc2 vf06,0x50(%0)
    sqc2 vf13,0x00(%1);sqc2 vf14,0x10(%1);sqc2 vf15,0x20(%1);sqc2 vf16,0x30(%1);sqc2 vf17,0x40(%1);sqc2 vf18,0x50(%1)
    " : : "r" (*pJdest) , "r" (*pJMdest));

    //** Store J and JM for body 1
    if(b1present) __asm__ __volatile__("
    sqc2 vf07,0x00(%0);sqc2 vf08,0x10(%0);sqc2 vf09,0x20(%0);sqc2 vf10,0x30(%0);sqc2 vf11,0x40(%0);sqc2 vf12,0x50(%0)
    sqc2 vf19,0x00(%1);sqc2 vf20,0x10(%1);sqc2 vf21,0x20(%1);sqc2 vf22,0x30(%1);sqc2 vf23,0x40(%1);sqc2 vf24,0x50(%1)
    " : : "r" (*pJdest+24) , "r" (*pJMdest+24));    

    //** Increment Jdest,JMdest Jsrc
    *pJbase=(*pJbase)+MAXPERROW*24;
    *pJMbase=(*pJMbase)+MAXPERROW*24;
    *pJdest=*pJbase;
    *pJMdest=*pJMbase;
    *pJsrc=(*pJsrc)+72;
/*
    //**Load J for both bodies from the next strip
    __asm__ __volatile__("
    lqc2 vf01,0x00(%0);lqc2 vf02,0x10(%0);lqc2 vf03,0x20(%0);lqc2 vf04,0x30(%0);lqc2 vf05,0x40(%0);lqc2 vf06,0x50(%0)
    lqc2 vf07,0x60(%0);lqc2 vf08,0x70(%0):lqc2 vf09,0x80(%0);lqc2 vf10,0x90(%0);lqc2 vf11,0xa0(%0);lqc2 vf12,0xb0(%0)
    " : : "r" (&Jsrc[0]));

    __asm__ __volatile__("
    __expression_asm
    Body0Jcol0
    Body0Jcol1
    Body0Jcol2
    Body0Jcol3
    Body0Jcol4
    Body0Jcol5
    Body1Jcol0
    Body1Jcol1
    Body1Jcol2
    Body1Jcol3
    Body1Jcol4
    Body1Jcol5
    Body0JMcol0
    Body0JMcol1
    Body0JMcol2
    Body0JMcol3
    Body0JMcol4
    Body0JMcol5
    Body1JMcol0
    Body1JMcol1
    Body1JMcol2
    Body1JMcol3
    Body1JMcol4
    Body1JMcol5
    invIwCol0
    invIwCol1
    invIwCol2
    invmass

    'lqc2 @invIwCol0,0x00(%0)
    'lqc2 @invIwCol1,0x10(%0)
    'lqc2 @invIwCol2,0x20(%0)
    'lqc2 @invmass,0x00(%1) 

    Body0JMcol0 = Body0Jcol0*invmass.z
    Body0JMcol1 = Body0Jcol1*invmass.z
    Body0JMcol2 = Body0Jcol2*invmass.z

    ACC         =     Body0Jcol3*invIwCol0.x
    ACC         = ACC+Body0Jcol4*invIwCol0.y
    Body0JMcol3 = ACC+Body0Jcol5*invIwCol0.z
    ACC         =     Body0Jcol3*invIwCol1.x
    ACC         = ACC+Body0Jcol4*invIwCol1.y
    Body0JMcol4 = ACC+Body0Jcol5*invIwCol1.z
    ACC         =     Body0Jcol3*invIwCol2.x
    ACC         = ACC+Body0Jcol4*invIwCol2.y
    Body0JMcol5 = ACC+Body0Jcol5*invIwCol2.z

    'lqc2 @invIwCol0,0x00(%2)
    'lqc2 @invIwCol1,0x10(%2)
    'lqc2 @invIwCol2,0x20(%2)
    'lqc2 @invmass,0x00(%3) 

    Body1JMcol0 = Body1Jcol0*invmass.z
    Body1JMcol1 = Body1Jcol1*invmass.z
    Body1JMcol2 = Body1Jcol2*invmass.z

    ACC         =     Body1Jcol3*invIwCol0.x
    ACC         = ACC+Body1Jcol4*invIwCol0.y
    Body1JMcol3 = ACC+Body1Jcol5*invIwCol0.z
    ACC         =     Body1Jcol3*invIwCol1.x
    ACC         = ACC+Body1Jcol4*invIwCol1.y
    Body1JMcol4 = ACC+Body1Jcol5*invIwCol1.z
    ACC         =     Body1Jcol3*invIwCol2.x
    ACC         = ACC+Body1Jcol4*invIwCol2.y
    Body1JMcol5 = ACC+Body1Jcol5*invIwCol2.z

    ~Body0Jcol0
    ~Body0Jcol1
    ~Body0Jcol2
    ~Body0Jcol3
    ~Body0Jcol4
    ~Body0Jcol5
    ~Body1Jcol0
    ~Body1Jcol1
    ~Body1Jcol2
    ~Body1Jcol3
    ~Body1Jcol4
    ~Body1Jcol5
    ~Body0JMcol0
    ~Body0JMcol1
    ~Body0JMcol2
    ~Body0JMcol3
    ~Body0JMcol4
    ~Body0JMcol5
    ~Body1JMcol0
    ~Body1JMcol1
    ~Body1JMcol2
    ~Body1JMcol3
    ~Body1JMcol4
    ~Body1JMcol5
    ~invIwCol0
    ~invIwCol1
    ~invIwCol2
    ~invmass

    __end_expression_asm
    " : : "r" (&body0invI[0]) , "r" (&body0[0]) ,"r" (&body1invI[0]) , "r"(&body1[0]));
*/
    MeReal mask1100[4] __attribute__ ((aligned(16))) = {1.0f,1.0f,0.0f,0.0f};
    //** Store J and JM for body 0
    __asm__ __volatile__("
    lqc2 vf31,0x00(%2)
    vmul vf25,vf01,vf31;vmul vf26,vf02,vf31;vmul vf27,vf03,vf31;vmul vf28,vf04,vf31;vmul vf29,vf05,vf31;vmul vf30,vf06,vf31
    sqc2 vf25,0x00(%0); sqc2 vf26,0x10(%0); sqc2 vf27,0x20(%0); sqc2 vf28,0x30(%0); sqc2 vf29,0x40(%0); sqc2 vf30,0x50(%0)    
    vmul vf25,vf07,vf31;vmul vf26,vf08,vf31;vmul vf27,vf09,vf31;vmul vf28,vf10,vf31;vmul vf29,vf11,vf31;vmul vf30,vf12,vf31
    sqc2 vf25,0x00(%1); sqc2 vf26,0x10(%1); sqc2 vf27,0x20(%1); sqc2 vf28,0x30(%1); sqc2 vf29,0x40(%1); sqc2 vf30,0x50(%1)
    " : : "r" (*pJdest) , "r" (*pJMdest), "r" (&mask1100[0]));

    //** Increment Jdest,JMdest
    *pJdest=(*pJdest)+24;
    *pJMdest=(*pJMdest)+24;

    //** Store J and JM for body 1

    if(b1present)
    {
    __asm__ __volatile__("
    vmul vf25,vf07,vf31;vmul vf26,vf08,vf31;vmul vf27,vf09,vf31;vmul vf28,vf10,vf31;vmul vf29,vf11,vf31;vmul vf30,vf12,vf31
    sqc2 vf25,0x00(%0);sqc2 vf26,0x10(%0);sqc2 vf27,0x20(%0);sqc2 vf28,0x30(%0);sqc2 vf29,0x40(%0);sqc2 vf30,0x50(%0)
    vmul vf25,vf19,vf31;vmul vf26,vf20,vf31;vmul vf27,vf21,vf31;vmul vf28,vf22,vf31;vmul vf29,vf23,vf31;vmul vf30,vf24,vf31
    sqc2 vf25,0x00(%1);sqc2 vf26,0x10(%1);sqc2 vf27,0x20(%1);sqc2 vf28,0x30(%1);sqc2 vf29,0x40(%1);sqc2 vf30,0x50(%1)
    " : : "r" (*pJdest) , "r" (*pJMdest));    

    //** Increment Jdest,JMdest
    *pJdest=(*pJdest)+24;
    *pJMdest=(*pJMdest)+24;
    }

    *offset=2;

}
void crossone14   (int *offset,int conssize,int b1present,MeReal **Jp,MeReal **JMp,MeReal **Jbase, MeReal **JMbase, 
                   MeReal **pJsrc,MdtKeaBody *body0,MdtKeaBody *body1,float *body0invI,float *body1invI) 
{   //printf("crossone    ");
    //printf("1 4 | 0 1 ",4-(*offset),(*offset)+conssize-4);
    *offset=(*offset)+conssize-4;
    //*stripnum=(*stripnum)+1;
}
void crossone15   (int *offset,int conssize,int b1present,MeReal **Jp,MeReal **JMp,MeReal **Jbase, MeReal **JMbase, 
                   MeReal **pJsrc,MdtKeaBody *body0,MdtKeaBody *body1,float *body0invI,float *body1invI) 
{   //printf("crossone    ");
    //printf("1 4 | 0 2 ",4-(*offset),(*offset)+conssize-4);
    *offset=(*offset)+conssize-4;
    //*stripnum=(*stripnum)+1;
}
void crossone16   (int *offset,int conssize,int b1present,MeReal **Jp,MeReal **JMp,MeReal **Jbase, MeReal **JMbase, 
                   MeReal **pJsrc,MdtKeaBody *body0,MdtKeaBody *body1,float *body0invI,float *body1invI) 
{   //printf("crossone    ");
    //printf("1 4 | 0 3 ",4-(*offset),(*offset)+conssize-4);
    *offset=(*offset)+conssize-4;
    //*stripnum=(*stripnum)+1;
}
void crossone23   (int *offset,int conssize,int b1present,MeReal **Jp,MeReal **JMp,MeReal **Jbase, MeReal **JMbase, 
                   MeReal **pJsrc,MdtKeaBody *body0,MdtKeaBody *body1,float *body0invI,float *body1invI) 
{   //printf("crossone    ");
    //printf("2 4 | 0 1 ",4-(*offset),(*offset)+conssize-4);
    *offset=(*offset)+conssize-4;
    //*stripnum=(*stripnum)+1;
}
void crossone24   (int *offset,int conssize,int b1present,MeReal **Jp,MeReal **JMp,MeReal **Jbase, MeReal **JMbase, 
                   MeReal **pJsrc,MdtKeaBody *body0,MdtKeaBody *body1,float *body0invI,float *body1invI) 
{   //printf("crossone    ");
    //printf("2 4 | 0 2 ",4-(*offset),(*offset)+conssize-4);
    *offset=(*offset)+conssize-4;
    //*stripnum=(*stripnum)+1;
}
void crossone25   (int *offset,int conssize,int b1present,MeReal **Jp,MeReal **JMp,MeReal **Jbase, MeReal **JMbase, 
                   MeReal **pJsrc,MdtKeaBody *body0,MdtKeaBody *body1,float *body0invI,float *body1invI) 
{   //printf("crossone    ");
    //printf("2 4 | 0 3 ",4-(*offset),(*offset)+conssize-4);
    *offset=(*offset)+conssize-4;
    //*stripnum=(*stripnum)+1;
}
void crossone32   (int *offset,int conssize,int b1present,MeReal **Jp,MeReal **JMp,MeReal **Jbase, MeReal **JMbase, 
                   MeReal **pJsrc,MdtKeaBody *body0,MdtKeaBody *body1,float *body0invI,float *body1invI) 
{   //printf("crossone    ");
    //printf("3 4 | 0 1 ",4-(*offset),(*offset)+conssize-4);
    *offset=(*offset)+conssize-4;
    //*stripnum=(*stripnum)+1;
}
void crossone33   (int *offset,int conssize,int b1present,MeReal **Jp,MeReal **JMp,MeReal **Jbase, MeReal **JMbase, 
                   MeReal **pJsrc,MdtKeaBody *body0,MdtKeaBody *body1,float *body0invI,float *body1invI) 
{   //printf("crossone    ");
    //printf("3 4 | 0 2 ",4-(*offset),(*offset)+conssize-4);
    *offset=(*offset)+conssize-4;
    //*stripnum=(*stripnum)+1;
}
void crossone34   (int *offset,int conssize,int b1present,MeReal **Jp,MeReal **JMp,MeReal **Jbase, MeReal **JMbase, 
                   MeReal **pJsrc,MdtKeaBody *body0,MdtKeaBody *body1,float *body0invI,float *body1invI) 
{   //printf("crossone    ");
    //printf("3 4 | 0 3 ",4-(*offset),(*offset)+conssize-4);
    *offset=(*offset)+conssize-4;
    //*stripnum=(*stripnum)+1;
}

void crossoneinc26(int *offset,int conssize,int b1present,MeReal **pJdest,MeReal **pJMdest,MeReal **pJbase, MeReal **pJMbase, 
                   MeReal **pJsrc,MdtKeaBody *body0,MdtKeaBody *body1,float *body0invI,float *body1invI) 
{   
    //printf("2 4 | 0 4 | ");

    //** Store J and JM for body 0
    
    __asm__ __volatile__("
    vmulx.xy vf01,vf0,vf0x;vmulx.xy vf02,vf0,vf0x;vmulx.xy vf03,vf0,vf0x;vmulx.xy vf04,vf0,vf0x;vmulx.xy vf05,vf0,vf0x;vmulx.xy vf06,vf0,vf0x
    vmulx.xy vf13,vf0,vf0x;vmulx.xy vf14,vf0,vf0x;vmulx.xy vf15,vf0,vf0x;vmulx.xy vf16,vf0,vf0x;vmulx.xy vf17,vf0,vf0x;vmulx.xy vf18,vf0,vf0x
    sqc2 vf01,0x00(%0);sqc2 vf02,0x10(%0);sqc2 vf03,0x20(%0);sqc2 vf04,0x30(%0);sqc2 vf05,0x40(%0);sqc2 vf06,0x50(%0)
    sqc2 vf13,0x00(%1);sqc2 vf14,0x10(%1);sqc2 vf15,0x20(%1);sqc2 vf16,0x30(%1);sqc2 vf17,0x40(%1);sqc2 vf18,0x50(%1)
    " : : "r" (*pJdest) , "r" (*pJMdest));

    //** Store J and JM for body 1
    if(b1present) __asm__ __volatile__("
    vmulx.xy vf1,vf0,vf0x;vmulx.xy vf2,vf0,vf0x;vmulx.xy vf3,vf0,vf0x;vmulx.xy vf4,vf0,vf0x;vmulx.xy vf5,vf0,vf0x;vmulx.xy vf6,vf0,vf0x
    vmulx.xy vf7,vf0,vf0x;vmulx.xy vf8,vf0,vf0x;vmulx.xy vf9,vf0,vf0x;vmulx.xy vf10,vf0,vf0x;vmulx.xy vf11,vf0,vf0x;vmulx.xy vf12,vf0,vf0x
    sqc2 vf07,0x00(%0);sqc2 vf08,0x10(%0);sqc2 vf09,0x20(%0);sqc2 vf10,0x30(%0);sqc2 vf11,0x40(%0);sqc2 vf12,0x50(%0)
    sqc2 vf19,0x00(%1);sqc2 vf20,0x10(%1);sqc2 vf21,0x20(%1);sqc2 vf22,0x30(%1);sqc2 vf23,0x40(%1);sqc2 vf24,0x50(%1)
    " : : "r" (*pJdest+24) , "r" (*pJMdest+24));

    //** Increment Jp,JMp
    *pJbase=(*pJbase)+MAXPERROW*24;
    *pJMbase=(*pJMbase)+MAXPERROW*24;
    *pJdest=*pJbase;
    *pJMdest=*pJMbase;
    *pJsrc=(*pJsrc)+72;

    //** Load J and Jm from the next source strip
    __asm__ __volatile__("
    lqc2 vf01,0x00(%0);lqc2 vf02,0x10(%0);lqc2 vf03,0x20(%0);lqc2 vf04,0x30(%0);lqc2 vf05,0x40(%0);lqc2 vf06,0x50(%0)
    lqc2 vf07,0x60(%0);lqc2 vf08,0x70(%0);lqc2 vf09,0x80(%0);lqc2 vf10,0x90(%0);lqc2 vf11,0xa0(%0);lqc2 vf12,0xb0(%0)
    " : : "r" (*pJsrc));

    //** Store J and JM for body 0
    __asm__ __volatile__("
    sqc2 vf01,0x00(%0)
    sqc2 vf02,0x10(%0)
    sqc2 vf03,0x20(%0)
    sqc2 vf04,0x30(%0)
    sqc2 vf05,0x40(%0)
    sqc2 vf06,0x50(%0)
    sqc2 vf13,0x00(%1)
    sqc2 vf14,0x10(%1)
    sqc2 vf15,0x20(%1)
    sqc2 vf16,0x30(%1)
    sqc2 vf17,0x40(%1)
    sqc2 vf18,0x50(%1)
    " : : "r" (*pJdest) , "r" (*pJMdest));

    if(b1present)
    {
    //** Store J and JM for body 1
    __asm__ __volatile__("
    sqc2 vf7,0x00(%0)
    sqc2 vf8,0x10(%0)
    sqc2 vf9,0x20(%0)
    sqc2 vf10,0x30(%0)
    sqc2 vf11,0x40(%0)
    sqc2 vf12,0x50(%0)
    sqc2 vf19,0x00(%1)
    sqc2 vf20,0x10(%1)
    sqc2 vf21,0x20(%1)
    sqc2 vf22,0x30(%1)
    sqc2 vf23,0x40(%1)
    sqc2 vf24,0x50(%1)
    " : : "r" (*pJdest+24) , "r" (*pJMdest+24));    
    }
    
    //** Increment Jp,JMp
    *pJbase=(*pJbase)+MAXPERROW*24;
    *pJMbase=(*pJMbase)+MAXPERROW*24;
    *pJdest=*pJbase;
    *pJMdest=*pJMbase;
    *pJsrc=(*pJsrc)+72;

    //** Load J and Jm from the next source strip
    __asm__ __volatile__("
    lqc2 vf01,0x00(%0);lqc2 vf02,0x10(%0);lqc2 vf03,0x20(%0);lqc2 vf04,0x30(%0);lqc2 vf05,0x40(%0);lqc2 vf06,0x50(%0)
    lqc2 vf07,0x60(%0);lqc2 vf08,0x70(%0);lqc2 vf09,0x80(%0);lqc2 vf10,0x90(%0);lqc2 vf11,0xa0(%0);lqc2 vf12,0xb0(%0)
    " : : "r" (*pJsrc));

    *offset=0;
}
void crossoneinc35(int *offset,int conssize,int b1present,MeReal **Jp,MeReal **JMp,MeReal **Jbase, MeReal **JMbase, 
                   MeReal **pJsrc,MdtKeaBody *body0,MdtKeaBody *body1,float *body0invI,float *body1invI) 
{   //printf("crossoneinc ");
    //printf("3 4 | 0 4 | ",4-(*offset),4);
    *offset=0;
    //*stripnum=(*stripnum)+2;
}
void crosstwo36   (int *offset,int conssize,int b1present,MeReal **Jp,MeReal **JMp,MeReal **Jbase, MeReal **JMbase, 
                   MeReal **pJsrc,MdtKeaBody *body0,MdtKeaBody *body1,float *body0invI,float *body1invI) 
{   //printf("crosstwo    ");
    //printf("3 4 | 0 4 | 0 1 ",4-(*offset),4,(*offset)+conssize-8);
    *offset=1;
    //*stripnum=(*stripnum)+2;
}

//**************************************************************
//uncomment these to print debugging info at each pipeline stage
//**************************************************************
//#define PRINT_KEA_INPUT_CONSTRAINTS
//#define PRINT_KEA_INPUT_BODIES
//#define PRINT_KEA_INPUT_TRANSFORMATIONS
//#define PRINT_KEA_INPUT_PARAMETERS
//#define PRINT_RHS_INPUT
//#define PRINT_FACTORISER_INPUT
//#define PRINT_LCP_OUTPUT
//#define PRINT_KEA_OUTPUT
//#define PRINT_INTEGRATOR_INPUT

//****************************************
// The most important function 
//****************************************

//#define Jpresent   constraints.Jpresent
#define Jstore     constraints.Jstore
#define Jbody      constraints.Jbody
#define xi         constraints.xi
#define c          constraints.c
#define lo         constraints.lo
#define hi         constraints.hi
#define lambda     constraints.lambda
#define slipfactor constraints.slipfactor
#define xgamma     constraints.xgamma
#define Jsize      constraints.Jsize
#define Jofs       constraints.Jofs

void MdtKeaStep(MdtKeaConstraints    constraints,
             MdtKeaBody           *blist,
	     MdtKeaTransformation *tlist, 
	     int               num_bodies,
	     MdtKeaParameters     parameters)
{
  int i,j,k,l,ofs,bi,partition;
  MeReal tmp2[8*8];
  int *pc;
  int *pb;
  int *pt;
  int m;
  
  if (num_bodies==0) return; 
  keaStartTiming(2);   
  keaInitPool(parameters.memory_pool,parameters.memory_pool_size);

  //*** Print the entire input (all partitions) for debugging purposes
  
  #ifdef PRINT_KEA_INPUT_CONSTRAINTS
  printf("KeaConstraints\n");
  printf("--------------\n");
  printf("num_partitions=            %d\n",constraints.num_partitions);
  printf("num_rows_partition=        ");for(i=0;i!=constraints.num_partitions;i++) printf("%d ",constraints.num_rows_partition[i]);printf("\n");
  printf("num_constraints_partition= ");for(i=0;i!=constraints.num_partitions;i++) printf("%d ",constraints.num_constraints_partition[i]);printf("\n");
  printf("num_rows=                  %d\n",constraints.num_rows);
  printf("num_constraints=           %d\n",constraints.num_constraints);
  printf("xi=                        ");for(i=0;i!=constraints.num_rows;i++) printf("%12.6f ",xi[i]);printf("\n");
  printf("c=                         ");for(i=0;i!=constraints.num_rows;i++) printf("%12.6f ",c[i]);printf("\n");
  printf("lo=                        ");for(i=0;i!=constraints.num_rows;i++) printf("%12.6f ",lo[i]);printf("\n");
  printf("hi=                        ");for(i=0;i!=constraints.num_rows;i++) printf("%12.6f ",hi[i]);printf("\n");
  printf("slipfactor=                ");for(i=0;i!=constraints.num_rows;i++) printf("%12.6f ",slipfactor[i]);printf("\n");
  printf("xgamma=                    ");for(i=0;i!=constraints.num_rows;i++) printf("%12.6f ",xgamma[i]);printf("\n");
  printf("jsize=                     ");for(i=0;i!=constraints.num_constraints;i++) printf("%d ",Jsize[i]);printf("\n");
  printf("jofs=                      ");for(i=0;i!=constraints.num_constraints;i++) printf("%d ",Jofs[i]);printf("\n");
  printf("jbody=                     ");for(i=0;i!=3*constraints.num_constraints;i++) printf("%d ",Jbody[i]);printf("\n");
  for(i=0;i!=constraints.num_rows/4;i++)
  {
      for(j=0;j!=4;j++)
      {
          for(k=0;k!=12;k++)
          {
              printf("%6.3f ",Jstore[j+k*4+i*72]);
          }
          printf("\n");  
      }
      printf("\n");
  }
  #endif

  #ifdef PRINT_KEA_INPUT_BODIES
  printf("keaBodies\n");
  printf("---------\n");
  
  #endif

  #ifdef PRINT_KEA_INPUT_TRANSFORAMTIONS
  printf("MdtKeaTransformations\n");
  printf("------------------\n");
  
  #endif

  #ifdef PRINT_KEA_INPUT_PARAMETERS
  printf("MdtKeaParameters\n");
  printf("-------------\n");
  printf("gamma   =%12.6f\n",parameters.gamma);
  printf("epsilon =%12.6f\n",parameters.epsilon);
  printf("stepsize=%12.6f\n",parameters.stepsize);
  #endif


  for (i=0; i<constraints.num_rows; i++) xgamma[i] += parameters.gamma;
            
  // Calculate Iworld and invIworld, which are
  // the inertia tensor and its inverse in the WORLD frame. NOTE! when we
  // multiply by inv(M) we should be using invIworld, *not* invI.
  // Modified 20000221 WFGG -> 4-vectors for integrator Grrrrrrrrrrrr

  keaTic("calculate Iworld and invIworld");  
  MeReal *Iworld = (MeReal*) keaStackAlloc (num_bodies*12*sizeof(MeReal));
  MeReal *invIworld = (MeReal*) keaStackAlloc (num_bodies*12*sizeof(MeReal));
  for (pt=(int *)tlist,pb=(int *)blist,bi=0; bi!=num_bodies; bi++,pb+=*(pb+1)/4,pt+=sizeof(MdtKeaTransformation)/4) 
  {
    MdtKeaBody *b=(MdtKeaBody *)pb;
    MdtKeaTransformation *t=(MdtKeaTransformation *)pt;
    
    MeReal sum;
    MeReal *answer;
    
    for (i=0; i!=3; i++) {
      for (j=0; j!=3; j++) {
	sum=0;
	for (k=0; k!=3; k++) sum += (b->invI0)[i*4+k]*(t->R0)[j*4+k];
	tmp2[i*3+j] = sum;
      }
    }
  
    answer=invIworld + bi*12;

    //#define CLAUDES_FIX
    #define ADDFR
    
    #ifdef CLAUDES_FIX
    for (i=0; i<3; i++) {
      for (j=0; j<3; j++) {
	sum=0;
	for (k=0; k<3; k++) sum += (t->R0)[i*4+k]*tmp2[k*3+j];
	*answer++  = sum;
      }
      *answer++ = 0.0f;
    }
    #else
    for (j=0; j!=3; j++) {
      for (i=0; i!=3; i++) {
	MeReal sum=0;
	MeReal *b = t->R0 + i;
	MeReal *d = tmp2 + j*3;
	for (int k=3; k!=0; k--) {
	  sum += (*b) * (*d);
	  b += 4;
	  d++;
	}
	*answer++ = sum;
      }
      *answer++ = 0.0f; // Padding!
    }
    #endif

   // First part of answer, therefore, contains nine values packed at the moment.
    
    for (i=0; i<3; i++) {
      for (j=0; j<3; j++) {
	sum=0;
	for (k=0; k!=3; k++) sum += (b->I0)[i*4+k]*(t->R0)[j*4+k];
	tmp2[i*3+j] = sum;
      }
    }

    answer=Iworld + bi*12;
    
    #ifdef CLAUDES_FIX
    for (i=0; i<3; i++) {
      for (j=0; j<3; j++) {
	sum=0;
	for (k=0; k<3; k++) sum += (t->R0)[i*4+k]*tmp2[k*3+j];
	*answer++  = sum;
      }
      *answer++ = 0.0f;
    }
    #else
    for (j=0; j<3; j++) {
      for (i=0; i<3; i++) {
	MeReal sum=0;
	MeReal *b = t->R0 + i;
	MeReal *d = tmp2 + j*3;
	for (int k=3; k!=0; k--) {
	  sum += (*b) * (*d);
	  b += 4;
	  d++;
	}
	*answer++ = sum;
      }
      *answer++ = 0.0f;
    }
    #endif
  }

  // BUG FIX BY RUSSELL, 3/Feb/2000:
  // add fr (the rotational force) to fe, for each body

  for (bi=0, pb=(int *)blist; bi!=num_bodies; bi++, pb+=*(pb+1)/4 ) {     
    MdtKeaBody* bod = (MdtKeaBody*) pb;
    MeReal *T2 = tmp2;
    for (int i=0; i<3; i++) {
        MeReal sum=0;
        MeReal *b = Iworld + bi*12 + i;
        MeReal *d =  bod->velrot;
        for (int k=3; k!=0; k--) {
            sum += (*b) * (*d);
            b += 4;
            d++;
        }
        *T2++ = sum;
    }
    keaCross (bod->velrot,tmp2,tmp2+3);
    
    #ifdef ADDFR
    if(constraints.num_constraints>0)
        for (i=0; i!=3; i++) bod->torque[i] -= tmp2[i+3];
    #endif
  }
  
  keaTic("Convert J");

  int constraint,body,row,col,baserow,consoffset;
  MeReal *src=Jstore;
  int totalrows;
  
  for(totalrows=0,i=0;i!=constraints.num_partitions;i++) totalrows+=constraints.num_rows_partition[i];
  for(m=0,i=0;i!=constraints.num_partitions;i++) m+=constraints.num_constraints_partition[i];

  MeReal *oldJstore=(MeReal *)keaStackAlloc(totalrows*18*sizeof(MeReal));
  MeReal *dest=oldJstore;

  for(partition=0,baserow=0,consoffset=0;partition!=constraints.num_partitions;partition++)
  {
      for(constraint=0;constraint!=constraints.num_constraints_partition[partition];constraint++,consoffset++)
      {
          for(body=0;body!=3;body++)
          {
              for(row=0;row!=Jsize[consoffset];row++)
              {
                   for(col=0;col!=6;col++)
                   {
                       dest[col+row*6+body*Jsize[consoffset]*6]=src[col*4+((baserow+row)/4)*18*4+(baserow+row)%4+body*4*6];
                   }
              }
          }
          dest+=18*Jsize[consoffset];
          baserow+=Jsize[consoffset];
      }
      baserow=ceil4(baserow);
  }
  
  //if(fr==551) {printf("lo         =");for(i=0;i!=24;i++) printf("%17.6f ",lo[i]); printf("\n");}

  for(partition=0;partition!=constraints.num_partitions;partition++)
  {
  if (constraints.num_constraints_partition[partition] > 0) 
  {
    keaPushPoolFrame();
    
    m=constraints.num_constraints_partition[partition];
    int size=constraints.num_rows_partition[partition];
    int c4size;
    c4size=ceil4(size);
    int num4rows=c4size/4;

    //*******************************************************************************************
    // Extract J blocks from the J strips and make the JM blocks
    //
    // vf[1..7)   J0
    // vf[7..13)  J1
    // vf[13..19) JM0
    // vf[19..25) JM1
    // vf[25..28) InvIw

    #if 0
    keaTic ("New J and JM blocks maker");
    
    void (*stripJumpTable[]) (int *offset,int conssize,int b1present,MeReal **Jp,MeReal **JMp,MeReal **Jbase, MeReal **JMbase, 
                              MeReal **pJsrc,MdtKeaBody *body0,MdtKeaBody *body1,float *body0invI,float *body1invI) = 
    { 
      nocross01,   nocross02,   nocross03,   nocrossinc04,crossone05,   crossone06,
      nocross11,   nocross12,   nocrossinc13,crossone14,  crossone15,   crossone16,
      nocross21,   nocrossinc22,crossone23,  crossone24,  crossone25,   crossoneinc26,
      nocrossinc31,crossone32,  crossone33,  crossone34,  crossoneinc35,crosstwo36
    };
    
    int offset=0;
    int stripnum=0;
    MeReal *newJvectorstore=(MeReal *)keaStackAlloc(MAXPERROW*num4rows*24*sizeof(MeReal));
    MeReal *newJMvectorstore=(MeReal *)keaStackAlloc(MAXPERROW*num4rows*24*sizeof(MeReal));
    MeReal *Jdest=newJvectorstore;
    MeReal *JMdest=newJMvectorstore;
    MeReal *Jbase=Jdest;
    MeReal *JMbase=JMdest;
    MeReal *Jsrc=Jstore;

    //**** Initialise the invariant that vf[1..7) contains the current body0 strip, vf[7..13) constains the body1 strip
    __asm__ __volatile__("
    __expression_asm
    Body0Jcol0
    Body0Jcol1
    Body0Jcol2
    Body0Jcol3
    Body0Jcol4
    Body0Jcol5
    Body1Jcol0
    Body1Jcol1
    Body1Jcol2
    Body1Jcol3
    Body1Jcol4
    Body1Jcol5
    
    'lqc2 @Body0Jcol0,0x00(%0)
    'lqc2 @Body0Jcol1,0x10(%0)
    'lqc2 @Body0Jcol2,0x20(%0)
    'lqc2 @Body0Jcol3,0x30(%0)
    'lqc2 @Body0Jcol4,0x40(%0)
    'lqc2 @Body0Jcol5,0x50(%0)
    'lqc2 @Body1Jcol0,0x60(%0)
    'lqc2 @Body1Jcol1,0x70(%0)
    'lqc2 @Body1Jcol2,0x80(%0)
    'lqc2 @Body1Jcol3,0x90(%0)
    'lqc2 @Body1Jcol4,0xa0(%0)
    'lqc2 @Body1Jcol5,0xb0(%0)
 
    __end_expression_asm
    " : : "r" (&Jsrc[0]));

    //Calculate JM for this constraint
    __asm__ __volatile__("
    __expression_asm
    Body0JMcol0
    Body0JMcol1
    Body0JMcol2
    Body0JMcol3
    Body0JMcol4
    Body0JMcol5
    Body1JMcol0
    Body1JMcol1
    Body1JMcol2
    Body1JMcol3
    Body1JMcol4
    Body1JMcol5
    invIwCol0
    invIwCol1
    invIwCol2
    invmass

    'lqc2 @invIwCol0,0x00(%0)
    'lqc2 @invIwCol1,0x10(%0)
    'lqc2 @invIwCol2,0x20(%0)
    'lqc2 @invmass,0x00(%1) 

    Body0JMcol0 = Body0Jcol0*invmass.z
    Body0JMcol1 = Body0Jcol1*invmass.z
    Body0JMcol2 = Body0Jcol2*invmass.z

    ACC         =     Body0Jcol3*invIwCol0.x
    ACC         = ACC+Body0Jcol4*invIwCol0.y
    Body0JMcol3 = ACC+Body0Jcol5*invIwCol0.z
    ACC         =     Body0Jcol3*invIwCol1.x
    ACC         = ACC+Body0Jcol4*invIwCol1.y
    Body0JMcol4 = ACC+Body0Jcol5*invIwCol1.z
    ACC         =     Body0Jcol3*invIwCol2.x
    ACC         = ACC+Body0Jcol4*invIwCol2.y
    Body0JMcol5 = ACC+Body0Jcol5*invIwCol2.z

    'lqc2 @invIwCol0,0x00(%2)
    'lqc2 @invIwCol1,0x10(%2)
    'lqc2 @invIwCol2,0x20(%2)
    'lqc2 @invmass,0x00(%3) 

    Body1JMcol0 = Body1Jcol0*invmass.z
    Body1JMcol1 = Body1Jcol1*invmass.z
    Body1JMcol2 = Body1Jcol2*invmass.z

    ACC         =     Body1Jcol3*invIwCol0.x
    ACC         = ACC+Body1Jcol4*invIwCol0.y
    Body1JMcol3 = ACC+Body1Jcol5*invIwCol0.z
    ACC         =     Body1Jcol3*invIwCol1.x
    ACC         = ACC+Body1Jcol4*invIwCol1.y
    Body1JMcol4 = ACC+Body1Jcol5*invIwCol1.z
    ACC         =     Body1Jcol3*invIwCol2.x
    ACC         = ACC+Body1Jcol4*invIwCol2.y
    Body1JMcol5 = ACC+Body1Jcol5*invIwCol2.z

    ~Body0Jcol0
    ~Body0Jcol1
    ~Body0Jcol2
    ~Body0Jcol3
    ~Body0Jcol4
    ~Body0Jcol5
    ~Body1Jcol0
    ~Body1Jcol1
    ~Body1Jcol2
    ~Body1Jcol3
    ~Body1Jcol4
    ~Body1Jcol5
    ~Body0JMcol0
    ~Body0JMcol1
    ~Body0JMcol2
    ~Body0JMcol3
    ~Body0JMcol4
    ~Body0JMcol5
    ~Body1JMcol0
    ~Body1JMcol1
    ~Body1JMcol2
    ~Body1JMcol3
    ~Body1JMcol4
    ~Body1JMcol5
    ~invIwCol0
    ~invIwCol1
    ~invIwCol2
    ~invmass

    __end_expression_asm
    " : : "r" (invIworld + Jbody[3*0+0] * 12), 
          "r" ((MdtKeaBody *)blist + Jbody[3*0+0]),
          "r" (invIworld + Jbody[3*0+1] * 12), 
          "r" ((MdtKeaBody *)blist + Jbody[3*0+1])
    );

    //** { body0JM is in vf[13..19) body1JM is in vf[19..25) }

    for(i=0;i!=1;i++)
    {
        MdtKeaBody *body0 = ((MdtKeaBody *)blist + Jbody[3*i+0]);
        MdtKeaBody *body1 = ((MdtKeaBody *)blist + Jbody[3*i+1]);
        
        stripJumpTable[offset*6+Jsize[i]-1] (&offset,Jsize[i],Jbody[3*i+1]!=-1,&Jdest,&JMdest,&Jbase,&JMbase,&Jsrc,
                                             body0,body1,invIworld + Jbody[3*i+0] * 12,invIworld + Jbody[3*i+1] * 12);
    }
    //printf("\n");

    //*** Print the input Jblocks for debugging purposes

    #if 0
    for(i=0;i!=c4size/4;i++)
    {
        for(j=0;j!=4;j++)
        {
            for(k=0;k!=12;k++)
            {
                printf("%6.3f ",Jstore[j+k*4+i*72]);
            }
            printf("\n");  
        }
        printf("\n");
    }
    #endif
    
    //*** Print the J strips for debugging purposes
    
    #if 0
    printf("J strips:\n");
    
    for(l=0;l!=c4size/4;l++)
    {    
        for(i=0;i!=4;i++)
        {
            for(k=0;k!=4;k++)
            {
                for(j=0;j!=6;j++)
                {
                    printf("%6.3f ",newJvectorstore[i+j*4+k*24+l*MAXPERROW*24]);
                }
                printf("| ");
            }
            printf("\n");
        }
        printf("\n");
    }
    #endif

    //*** Print the JM strips for debugging purposes
    
    #if 0
    printf("JM strips:\n");
    
    for(l=0;l!=c4size/4;l++)
    {    
        for(i=0;i!=4;i++)
        {
            for(k=0;k!=4;k++)
            {
                for(j=0;j!=6;j++)
                {
                    printf("%6.3f ",newJMvectorstore[i+j*4+k*24+l*MAXPERROW*24]);
                }
                printf("| ");
            }
            printf("\n");
        }
        printf("\n");
    }
    #endif
    #endif
    keaTic ("Make packed J and JM blocks");
    
    //*** Print debugging information
    
    //printf("size=%d\n",size);
    //for(i=0;i!=m;i++) printf("%10d\n",Jsize[i]);
    //printf("lo         =");for(i=0;i!=size;i++) printf("%17.6f ",lo[i]); printf("\n");
    //printf("hi         =");for(i=0;i!=size;i++) printf("%17.6f ",hi[i]); printf("\n");
    
    //*** Allocate memory
    LOCAL_ARRAY (tmp,num_bodies*8);
    
    typedef MeVector4 vectorblock[6];
    
    num4rows = (size +3 ) /4;

    MeReal* jmvectorstore;keaPoolAlloc(jmvectorstore,MAXPERROW*num4rows*4*6*sizeof(MeReal),"jmvectorstore");
    MeReal* jvectorstore ;keaPoolAlloc(jvectorstore,MAXPERROW*num4rows*4*6*sizeof(MeReal),"jvectorstore");
    int*    bodyrefersto =(int*)   keaStackAlloc((MAXPERROW+1)*num4rows*sizeof(int));
    keaSetZeroVec4((MeReal *)jmvectorstore, 24*num4rows*MAXPERROW);
    keaSetZeroVec4((MeReal *)jvectorstore, 24*num4rows*MAXPERROW);

    // The +1 is to provide a row of -1s to catch us at the end if necessary
    int *temp = bodyrefersto;
    for (i=0; i!=(num4rows*(MAXPERROW+1)); i++) *(temp++) = -1; // faster than mine for the time being.
    
    MeReal* jstoreptr;
    MeReal* jmstoreptr;
    MeReal* jptr;

    // jvector store stored aligned but row ordered, in same way as Jstore.
    // jmvector store stored column-vectorwise.

    int current1row = 0, current4row = 0;
    int firstrow, lastrow, rowoffset, rowscopied;
    bool foundone;
    
    MeReal* jptr2=oldJstore;
    
    for(int constraint = 0; constraint != m; constraint++) {
        firstrow = current1row;
        current1row += Jsize[constraint];
        lastrow = current1row - 1;

        for(int jblock = 0; jblock != 3; jblock++,jptr2+=Jsize[constraint]*6) 
	{
            int store;
            if(Jbody[(constraint*3)+jblock]!=-1) 
	    {
                current4row = firstrow / 4;
                rowoffset = firstrow % 4;
                foundone = FALSE;
                for(store = 0; (store != MAXPERROW) && (!foundone); store++) 
		{
                    if(bodyrefersto[num4rows*store+current4row] == Jbody[(constraint*3)+jblock])
                    {foundone = TRUE; //printf("found one readymade at %d, %d\n", current4row, store); 
                    }
                    
                    if(bodyrefersto[num4rows*store+current4row] == -1) {
                        bodyrefersto[num4rows*store+current4row] = Jbody[(constraint*3)+jblock];
                        foundone = TRUE; //printf("found an empty one at %d, %d\n", current4row, store);
                    }
                }
                //assert(foundone==TRUE);
                store--;
                
		// copy into jstore element by element (yeugh)...
		// Also, create here JM :O
                
                rowscopied = 0;
                jptr=jptr2;
		//*** Put as much stuff we can before hitting a boundary 
		
		for(int row = rowoffset; (row != 4) && (rowscopied != Jsize[constraint]); row++) 
		{
                    // copy the data from the jacobian block into the strip
                    jstoreptr  = jvectorstore +store*4*6*num4rows+4*6*current4row+0*4+row;
		    jmstoreptr = jmvectorstore+store*4*6*num4rows+4*6*current4row+0*4+row;
		    
		    MdtKeaBody *b = &((MdtKeaBody *)blist)[Jbody[3*constraint + jblock]];
                    for(int jcol = 0; jcol != 3; jcol++) {
                        *jstoreptr = *jptr;
                        *jmstoreptr = *jptr * b->invmass;
                        jstoreptr += 4;
                        jmstoreptr+= 4;
                        jptr++;
                    }
                    MeReal *invIw = invIworld + (Jbody[3*constraint + jblock] * 12); // Get invIworld corresponding to this body.
                    for(int k = 0; k != 3; k++) { // The second three columns
                        *jstoreptr = *jptr;
                         *jmstoreptr = ( *jptr * invIw[k*4+0] +
                                         *jptr * invIw[k*4+1] +
                                         *jptr * invIw[k*4+2]); 
                        jstoreptr += 4;
                        jmstoreptr += 4;
                        jptr++;
                    }
                    rowscopied++;
                }
                
		//*** If the block is not done then start filling up the other side of the boundary 
		
                //if(current4row != (lastrow  / 4) ) 
		if(rowscopied!=Jsize[constraint])
		//if(0)
		{
                        // We go over a block boundary; blast, will have to copy the rest now :/
                    //current4row = lastrow  / 4;
                    current4row++;
		    
                    foundone = FALSE;
                    for(store = 0; (store != MAXPERROW) && (!foundone); store++) {
                        if(bodyrefersto[num4rows*store+current4row] == Jbody[(constraint*3)+jblock])
                        {foundone = TRUE;//printf("found one readymade\n"); 
                         }
                        
                        if(bodyrefersto[num4rows*store+current4row] == -1) {
                            bodyrefersto[num4rows*store+current4row] = Jbody[(constraint*3)+jblock];
                            foundone = TRUE;//printf("found a new one\n"); 
                        }
                    }
                    //assert(foundone);
                    store--;
                    
                    for(int row = 0; (row != 4) && (rowscopied != Jsize[constraint]); row++) 
		    {
                	jstoreptr  = jvectorstore +store*4*6*num4rows+4*6*current4row+0*4+row;
			jmstoreptr = jmvectorstore+store*4*6*num4rows+4*6*current4row+0*4+row;                        
			
			MdtKeaBody *b = &((MdtKeaBody *)blist)[Jbody[3*constraint + jblock]];
                        for(int jcol = 0; jcol != 3; jcol++) {
                            *jstoreptr = *jptr;
                            *jmstoreptr = *jptr * b->invmass;
                            jstoreptr += 4;
                            jmstoreptr+= 4;
                            jptr++;
                        }
                        MeReal *invIw = invIworld + (Jbody[3*constraint + jblock] * 12); // Get invIworld corresponding to this body.
                        for(int k = 0; k != 3; k++) { // The second three columns
                            *jstoreptr = *jptr;
                            *jmstoreptr = ( *jptr * invIw[k*4+0] +
                                            *jptr * invIw[k*4+1] +
                                            *jptr * invIw[k*4+2]); 
                            jstoreptr += 4;
                            jmstoreptr += 4;
                            jptr++;
                        }
                        rowscopied++;
                    } // do copy
                } // over chunk boundary -> second copy op.
		
		//*** If the block is not done then start filling up the other side of the boundary 
		
		if(rowscopied!=Jsize[constraint] ) 
		{
		    current4row++;
		    foundone = FALSE;
                    for(store = 0; (store != MAXPERROW) && (!foundone); store++) {
                        if(bodyrefersto[num4rows*store+current4row] == Jbody[(constraint*3)+jblock])
                        {foundone = TRUE;//printf("found one readymade\n"); 
                         }
                        
                        if(bodyrefersto[num4rows*store+current4row] == -1) {
                            bodyrefersto[num4rows*store+current4row] = Jbody[(constraint*3)+jblock];
                            foundone = TRUE;//printf("found a new one\n"); 
                        }
                    }
                    store--;
                    
                    for(int row = 0; (row != 4) && (rowscopied != Jsize[constraint]); row++) 
		    {
                        jstoreptr  = jvectorstore +store*4*6*num4rows+4*6*current4row+0*4+row;
		        jmstoreptr = jmvectorstore+store*4*6*num4rows+4*6*current4row+0*4+row;

			MdtKeaBody *b = &((MdtKeaBody *)blist)[Jbody[3*constraint + jblock]];
                        for(int jcol = 0; jcol != 3; jcol++) {
                            *jstoreptr = *jptr;
                            *jmstoreptr = *jptr * b->invmass;
                            jstoreptr += 4;
                            jmstoreptr+= 4;
                            jptr++;
                        }
                        MeReal *invIw = invIworld + (Jbody[3*constraint + jblock] * 12); // Get invIworld corresponding to this body.
                        for(int k = 0; k != 3; k++) { // The second three columns
                            *jstoreptr = *jptr;
                            *jmstoreptr = ( *jptr * invIw[k*4+0] +
                                            *jptr * invIw[k*4+1] +
                                            *jptr * invIw[k*4+2]); 
                            jstoreptr += 4;
                            jmstoreptr += 4;
                            jptr++;
                        }
                        rowscopied++;
                    } // do copy
		}
	    } // if Jpresent
        } // for each of the three possibly present j blocks
    } // for each constraint.

    //*** Print the J strips for debugging purposes
    
    #if 0
    printf("J strips:\n");
    
    for(l=0;l!=c4size/4;l++)
    {    
        for(i=0;i!=4;i++)
        {
            for(k=0;k!=4;k++)
            {
                for(j=0;j!=6;j++)
                {
                    printf("%6.3f ",jvectorstore[i+j*4+l*24+k*num4rows*24]);
                }
                printf("| ");
            }
            printf("\n");
        }
        printf("\n");
    }
    #endif

    //*** Print the JM strips for debugging purposes
    
    #if 0
    printf("JM strips:\n");
    
    for(l=0;l!=c4size/4;l++)
    {    
        for(i=0;i!=4;i++)
        {
            for(k=0;k!=4;k++)
            {
                for(j=0;j!=6;j++)
                {
                    printf("%6.3f ",jmvectorstore[i+j*4+l*24+k*num4rows*24]);
                }
                printf("| ");
            }
            printf("\n");
        }
        printf("\n");
    }
    #endif
    
    #ifdef PRINT_RHS_INPUT
    printf("xgamma= ");for(i=0;i!=c4size;i++) printf("%12.6f ",xgamma[i]);printf("\n");
    #endif
     
    //.......................................................................
    // compute the right hand side we are solving for. this depends on the
    // stabilization method
    //
    // Input data:
    //
    // body     - linked list of bodies
    // Jsize
    // JBody
    // Jofs
    // stepsize - array
    // c        - array
    // xi       - array
    // hinv
    // m
    // gamma    - constant?
    //
    // Output data:
    //
    // rhs

    // set: rhs = c/h - gamma*xi/(h^2) - J*(vel(:)/h + inv(M)*fe(:));

    keaTic ("compute RHS");
    
    // tmp = inv(M)*fe(:)
    MeReal hinv = MeRecip(parameters.stepsize);
    
    for (bi=0, pb=(int *)blist, ofs=0; bi!=num_bodies; bi++, pb+=*(pb+1)/4, ofs+=8 ) {   
      MdtKeaBody* b = (MdtKeaBody*) pb;  
      for (j=0; j<3; j++) tmp[ofs+j] = b->force[j] * b->invmass;
      MeReal *invIw= invIworld + bi * 12;
      for (j=0; j<3; j++) tmp[ofs+3+j] =
				b->torque[0]*invIw[j*4+0] +
				b->torque[1]*invIw[j*4+1] +
				b->torque[2]*invIw[j*4+2];
    }
    
    // tmp += vel(:)/h
    for (bi=0, pb=(int *)blist, ofs=0; bi!=num_bodies; bi++, pb+=*(pb+1)/4, ofs+=8 ) {   
      MdtKeaBody* b = (MdtKeaBody*) pb;  
      for (i=0; i<3; i++) tmp[ofs+i] += hinv*b->vel[i];
      for (i=4; i<7; i++) tmp[ofs+i-1] += hinv*b->vel[i];
    }
    
    
    // rhs = J*tmp
    LOCAL_ARRAY (rhs,c4size);
    keaSetZeroVec4(rhs, c4size);

    //printf("rhs=%08x\n",rhs);

    // Now, calculate the RHS from the J blocks, easy as pi.

    for(int current4row = 0; current4row != num4rows; current4row++) {
        for(int col = 0; bodyrefersto[num4rows*col+current4row] != -1; col++) {
            MeReal* T = &(tmp[8*(bodyrefersto[num4rows*col+current4row])]); // pointer to the six floats per body
            MeReal* jptr = jvectorstore+4*6*num4rows*col+4*6*current4row+4*0+0;
            
	    asm __volatile__("

            __expression_asm

            tmp1
            tmp2

            j0
            j1
            j2
            j3
            j4
            j5

'           lqc2 @tmp1, 0x00(%0)
'           lqc2 @tmp2, 0x10(%0)
            
'           lqc2 @j0, 0x00(%1)
'           lqc2 @j1, 0x10(%1)
'           lqc2 @j2, 0x20(%1)
'           lqc2 @j3, 0x30(%1)
'           lqc2 @j4, 0x40(%1)
'           lqc2 @j5, 0x50(%1)

            rhs

'           lqc2 @rhs, 0(%2)

            ACC = K * K.x 
            
            ACC = ACC + j0 * tmp1.x
            ACC = ACC + j1 * tmp1.y
            ACC = ACC + j2 * tmp1.z
            ACC = ACC + j3 * tmp1.w
            ACC = ACC + j4 * tmp2.x
            ACC = ACC + j5 * tmp2.y

            ~tmp1
            ~tmp2

            ~j0
            ~j1
            ~j2
            ~j3
            ~j4
            ~j5

            rhs = ACC + rhs * K.w
            
'           sqc2 @rhs, 0(%2)

            ~rhs

            __end_expression_asm

        " : : "r" (T), "r" (jptr), "r" (&(rhs[4*current4row])) );
        }
    }
    //printf("3\n");
    MeReal        invh2              = MeRecip(parameters.stepsize*parameters.stepsize);
    MeReal*       xgammaptr          = &(xgamma[0]);
    MeVector4     usefuldata         = { hinv, invh2, 0, 0 };
    unsigned int* vectoraddresses[4] = { (unsigned int*)&(rhs[0]), (unsigned int*)&(c[0]), (unsigned int*)&(xi[0]), (unsigned int*)num4rows };

    // TODO: Concatenate these two blox of asm, take loop logic into asm.
    // FIXME: Using this block of asm actually slows down the ensuing code at this time, resulting in an overall slowdown.
    
    asm __volatile__("
    __expression_asm

                 c
                 xi
                 xgamma
                 rhs
                 usefuldata
                 xixgamma

    # $11 = num4rows ... $8 = addr of rhs ... $9 = addr of c ... $10 = addr of xi

                 'lw $11, 0x1c(%0)
                 'lw $8,  0x10(%0)
                 'lw $9,  0x14(%0)
                 'lw $10, 0x18(%0)
                 'lw $13, 0x00(%1)
    # num4rows*16 is number of bytes in rhs vector.
                 'sll $11, $11, 4
                 'lqc2 @usefuldata, 0x00(%0)
    # $12 = addr of just after the end of rhs
                 'add $12, $8, $11  

    '0:
                 # inner loop
                 
                 'lqc2 @xi,     0($10)
                 'lqc2 @xgamma, 0($13)
                 'lqc2 @c,      0($9)
                 'lqc2 @rhs,    0($8)

                 xixgamma = xi * xgamma
                 
                 ACC = K * K.x
                 ACC = ACC + c * usefuldata.x
                 ACC = ACC - xixgamma * usefuldata.y
                 rhs = ACC - rhs * K.w

                 # loop maintenance + store result

    # Get out if we've actually finished already (pipeline)
    # Bloody idioticompiler needlessly inserts a nop here, incidentally. Wonder if c'warrior does.
    # Or indeed the Cygnus one. Must find out.
                'beq $8, $12, 1f
                'addi $9, 0x10
                'addi $10, 0x10
                'sqc2 @rhs, 0($8)
                'addi $8, 0x10
                'addi $13, 0x10
                # end of inner loop

                'j 0b
                #'bnel $8, $12, 0b
                ~c
                ~xi
                ~rhs
                ~usefuldata
    '1:
    __end_expression_asm
    " : : "r" (&(usefuldata[0])), "r" (&(xgammaptr)) : "$8", "$9", "$10", "$11", "$12", "$13" );
    
    //printf("4\n");
         
    // Do the matrix asssignment:
    //
    //    tmp2     :=  tmp segment * Jcp block
    //
    // which looks like (in the case that Jsize[i/3]==3) :
    //
    // | . . . 0 | := |. . . . . .| | . . . 0|
    //  			    | . . . 0|
    //  			    | . . . 0|
    //  			    | . . . 0|
    //  			    | . . . 0|
    //  			    | . . . 0|
    //  			    <-c4jsize->
    //
    // In this example, the Jcp block is 3 wide but has been padded to 4 wide,
    // but other possibilities are 1 wide padded to 4 and 5 wide padded to 8
    // other widths (up to 6) may be required in the future.
	

    //.......................................................................
    // compute the problem matrix: A = J*inv(M)*J'.
    //
    // Input data:
    //
    // stack      - blocks of J are held on stack 
    //              ~3k of stack is used for this on testkea
    // m          = number of constraints 
    //              m is between 9 and 14 for testkea
    // JSize      = array of length m
    //              gives number of rows of block
    // barray     = array of pointers to bodies
    //              body fields accessed:
    //              invmass - inverse of mass
    //              invI    - inverse of inertia tensor (3*3)
    //              length is the number of bodies
    //              for testkea this length is 10
    // JBody      = array of size 3*m
    // tmp2       = 6*6 float temporary
    // slipfactor = array of length size
    // timestep   = the timestep set by the user
    // size       = sum of all the jsize
    //
    // Local data:
    //
    // JMStore    = (size 12*m bytes)
    //
    // Output data:
    // 
    // A

    
    keaTic("New Calculate A");

        // Warning, alignment/order of following variables is important

        // First 8-short-word:
     int currentcolumn __attribute__((aligned(16)));
     int colstore;
     int currentrow;
     int rowstore;
    
     MeReal *newA; keaPoolAlloc(newA,c4size*c4size*sizeof(MeReal),"newA");
     MeReal *Ainv; keaPoolAlloc(Ainv,c4size*c4size*sizeof(MeReal),"Ainv");
//     MeReal *newA = (MeReal *)0x70000000;
//     MeReal *Ainv = (MeReal *)0x70002000;
     

//     keaSetZero(newA, c4size*c4size);

    MeReal* newAptr = (MeReal *)newA;
    
    float* pj;
    float* pjm;
    int* pbrtc;
    int* pbrtr;
    
    for(currentcolumn = 0; currentcolumn != num4rows; currentcolumn++) 
    {
        pj = jvectorstore+4*6*num4rows*0+4*6*currentcolumn+4*0+0;
	pbrtc = &bodyrefersto[num4rows*0+currentcolumn];
        for(currentrow = currentcolumn; currentrow != num4rows; currentrow++) 
	{            
            pjm = jmvectorstore+4*6*num4rows*0+4*6*currentrow+4*0+0;
            pbrtr = &bodyrefersto[num4rows*0+currentrow];

            // printf("Calculating for column %x, row %x\n", currentcolumn, currentrow);            
            // printf("pj %x\tpjm %x\tpbrtc %x\tpbrtr %x\n", &pj, &pjm, &pbrtc, &pbrtr);
            
            __asm__ __volatile__("

            # Register allocation:
            # $10 = colstore x 4 ( (sizeof(float) and sizeof(int)))
            # $11 = rowstore x4
            # $12 = col - bodyrefersto value
            # $13 = row - bodyrefersto value

            # $15 = address of a first element of bodyrefersto[col]
            # $16 = address of a first element of bodyrefersto[row]

            # $17 = address of first element of a jvectorblock[col]
            # $18 = address of first element of a jmectorblock[row]

            # $25 = address of current bodyrefersto[row]
            # $24 = address of current jmvectorblock[row]

            # $8 = MAXPERROW (multiplied by 4 at start)
            # $20 = start of next bodyrefersto group (col)
            # $21 = start of next bodyrefersto group (row)

            __expression_asm

            # zero colstore, and the vector accumulators
            # Set up initial values of pointers, + max values

            # 
            # 	move $9, $0
            #num4rows
            'lw $8, 0(%5)
            'li $11, 0x60
            # Increment for bodyrefersto matrix
            'sll $9, $8, 2
            #Increment for data matrix
            'mult $10, $8, $11

            # This is MAXPERROW
            #'                      li $8, 8
            # reference number locations
            '                       lw $15, 0(%3)
            '                       lw $16, 0(%4)
            #'	sll $8, $8, 2
            # data block locations
            '                       lw $17, 0(%0)
            '                       lw $18, 0(%1)

            # Calculate byte length of a row of ints, add it to start of bodyrefersto row,

            #'	add $20, $8, $15
            #'	add $21, $8, $16

	    ansrow0
	    ansrow1
	    ansrow2
            ansrow3

            ansrow0 = K * K.x
            ansrow1 = K * K.x
            ansrow2 = K * K.x
            ansrow3 = K * K.x

            # If we've found a -1 for this column, branch out!
            #
            #
            'docol:
            #'	beq $15, $20, storeblock
            #set up 'beginning of row' values
            '	move $25, $16
            '	move $24, $18
            '	lw $12, 0($15)
            '	add $15, $15, $9
            # Don't forget Jblock - keep value in case we need it this time
            '           move $22, $17
            '	add $17, $17, $10
            '	beq $12, -1, storeblock

            # For each valid member of the current column

            'dorow:
            # if we've checked all the elements of a row, go to the next in the column
            #'	beq $25, $21, docol
            #load value for current row
            '	lw $13, 0($25)
            #increment bodyrefersto[col] pointer by four bytes (one int!)
            #and pointer to jmblock by 4 * 24 bytes
            '	add $25, $25, $9
            # Add24 should happen here, but must also be after the loads happen!!!!!
            '           move $23, $24
            '	add $24, $24, $10
            # if we've got to -1, go to the next in the column
            '	beq $13, -1, docol
            #is the bodyrefersto[row] the same as the value for the current column?
            #if not (likely), do the next row
            ' 	bnel $13, $12, dorow
            #
            # It's the same body! Hurray! Let loose the vector units of war!

                JMcol0
		JMcol1
		JMcol2
		JMcol3
		JMcol4
		JMcol5
		JTRANSrow0
		JTRANSrow1
		JTRANSrow2
		JTRANSrow3
		JTRANSrow4
		JTRANSrow5

		'lqc2 @JMcol0,0x00($23)
		'lqc2 @JMcol1,0x10($23)
		'lqc2 @JMcol2,0x20($23)
		'lqc2 @JMcol3,0x30($23)
		'lqc2 @JMcol4,0x40($23)
		'lqc2 @JMcol5,0x50($23)
		'lqc2 @JTRANSrow0,0x00($22)
		'lqc2 @JTRANSrow1,0x10($22)
		'lqc2 @JTRANSrow2,0x20($22)
		'lqc2 @JTRANSrow3,0x30($22)
		'lqc2 @JTRANSrow4,0x40($22)
		'lqc2 @JTRANSrow5,0x50($22)

                        ACC     = ansrow0+K.x
		ACC     = ACC+JTRANSrow0*JMcol0.x
		ACC     = ACC+JTRANSrow1*JMcol1.x
		ACC     = ACC+JTRANSrow2*JMcol2.x
		ACC     = ACC+JTRANSrow3*JMcol3.x
		ACC     = ACC+JTRANSrow4*JMcol4.x
		ansrow0 = ACC+JTRANSrow5*JMcol5.x

                        ACC     = ansrow1+K.x
		ACC     = ACC+JTRANSrow0*JMcol0.y
		ACC     = ACC+JTRANSrow1*JMcol1.y
		ACC     = ACC+JTRANSrow2*JMcol2.y
		ACC     = ACC+JTRANSrow3*JMcol3.y
		ACC     = ACC+JTRANSrow4*JMcol4.y
		ansrow1 = ACC+JTRANSrow5*JMcol5.y

                        ACC     = ansrow2+K.x
		ACC     = ACC+JTRANSrow0*JMcol0.z
		ACC     = ACC+JTRANSrow1*JMcol1.z
		ACC     = ACC+JTRANSrow2*JMcol2.z
		ACC     = ACC+JTRANSrow3*JMcol3.z
		ACC     = ACC+JTRANSrow4*JMcol4.z
		ansrow2 = ACC+JTRANSrow5*JMcol5.z
		
                        ACC     = ansrow3+K.x
		ACC     = ACC+JTRANSrow0*JMcol0.w
		ACC     = ACC+JTRANSrow1*JMcol1.w
		ACC     = ACC+JTRANSrow2*JMcol2.w
		ACC     = ACC+JTRANSrow3*JMcol3.w
		ACC     = ACC+JTRANSrow4*JMcol4.w
		ansrow3 = ACC+JTRANSrow5*JMcol5.w

                #li $9, 1

                ~JMcol0
		~JMcol1
		~JMcol2
		~JMcol3
		~JMcol4
		~JMcol5
		~JTRANSrow0
		~JTRANSrow1
		~JTRANSrow2
		~JTRANSrow3
		~JTRANSrow4
		~JTRANSrow5

            # If we got this far, we've done this pair. So, onto the next element in the column.

            'j	docol

            'storeblock:
            ' sqc2 @ansrow0, 0x00(%2)
            ' sqc2 @ansrow1, 0x10(%2)
            ' sqc2 @ansrow2, 0x20(%2)
            ' sqc2 @ansrow3, 0x30(%2)

            # If we got this far, we've done the whole darn thing, so we're outta here.

            __end_expression_asm
            " : : "r" (&pj), 
                  "r" (&pjm),
                  "r" (&newAptr[(4*c4size*currentcolumn) + (16*currentrow)]),
                  "r" (&pbrtc),
                  "r" (&pbrtr),
                  "r" (&num4rows) : "$8", "$9", "$10", "$11", "$12", "$13", "$15", "$16", "$17", "$18", "$20", "$21", "$22", "$23", "$24", "$25"
            );
        }
    }

    //.......................................................................

    keaTic("Copy lower,mod diag,copy");
        
    //**** Copy the upper triangle of A to the lower triangle and modify the diagonal	
    
    for(j=0;j!=size;j++) // j is destination column
    {
      for(i=0;i!=j;i++)
      {
        newA[((j/4)*c4size+i)*4+j%4]=newA[((i/4)*c4size+j)*4+i%4];  // newA(i,j)=newA(j,i)
      }
      newA[((j/4)*c4size+i)*4+j%4] += hinv*slipfactor[i]+parameters.epsilon; // Modify diagonal better done in here - takes advantage of fact that j=i after loop termination.
    }  

    //**** Copy A to Ainv for use by factoriser. Both are in wallpaper order
    
    MeReal* dest;
    MeReal* src;
    
    src=newA;
    dest=Ainv;
    for(i=0;i!=c4size*c4size/4;i++,dest+=4,src+=4)
    {
	   __asm__ __volatile__ ("
	   lqc2 vf1,0x00(%1)
	   sqc2 vf1,0x00(%0)
	   " : : "r" (dest),"r" (src));    
    }

    
    //*** Print the input to the factorisers for debugging purposes   

    #if PRINT_FACTORISER_INPUT
    for(i=0;i!=c4size;i++)
    {
       for(j=0;j!=c4size;j++) printf("%12.6f ",newA[((j/4)*c4size+i)*4+j%4]);
       printf("\n");       
    }
    printf("\n");
    printf("rhs        =");for(i=0;i!=size;i++) printf("%17.6f ",rhs[i]); printf("\n");
    printf("lo         =");for(i=0;i!=size;i++) printf("%17.6f ",lo[i]); printf("\n");
    printf("hi         =");for(i=0;i!=size;i++) printf("%17.6f ",hi[i]); printf("\n");
    #endif

    //.......................................................................
    // solve the linear system to find lambda
        
    keaTic ("factorize");
    keaVectorisedChol (Ainv,c4size);
    
    keaLCPDenseMatrix_optim matrix;
    matrix.n = size;
    matrix.Ainv = Ainv;
    matrix.epsilon = parameters.epsilon;
    matrix.A=newA;
    
    keaLCP (&matrix,lambda,rhs,lo,hi);
  
    //**** Print output of LCP for debugging purposes

    #ifdef PRINT_LCP_OUTPUT
    printf("lambda= ");for(i=0;i!=size;i++) printf("%12.6f ",lambda[i]);printf("\n");
    #endif

    //.........................................................................
    // given lambda, calculate resultant forces
    //
    // force(:) = force(:) + J'*lambda;
    //
    // Input data:
    //
    // size
    // m
    // n
    // Jsize
    // lambda
    // Joffs
    // JBody
    // body
    //   accessed:
    //   fe
    //   invmass
    //   invI
    //   vel
    // stepsize
    //
    // Output data:
    //
    // body - 
    //	  fields written:
    //	  fe  - accumulator of external forces on body
    //	  vel - center of mass velocity and angular velocity

    // suppose L is the segment of the lamda vector corresponing to constraint i/3
    // suppose J is the Jacobean block corresponding to body body[i]
    // calculate tmp2 = L*J
    //
    // example
    //
    //       tmp2          =      L             J
    //
    // | . . . 0 . . . 0 | =  | . . . | | . . . 0 . . . 0 | 
    //                                  | . . . 0 . . . 0 |
    //                                  | . . . 0 . . . 0 |
    //
    // in this example, jsize[i/3]=3, but the possible values are 1,3,5 and other values (up to 6 may be required in the future)
    // note the matrix is padded with 2 zeros

    keaTic ("calculate resultant forces");
  
    MdtKeaBody *bodyarray=(MdtKeaBody *)blist;

    for(int current4row = 0; current4row != num4rows; current4row++) 
    {
        for(int col = 0; bodyrefersto[num4rows*col+current4row] != -1; col++) 
	{
            MeReal* L = &(lambda[current4row*4]);
            MeReal* jptr = jvectorstore+4*6*num4rows*col+4*6*current4row+4*0+0;
	    
            asm __volatile__("
            __expression_asm

            lambda
            force
            torque
            j0
            j1
            j2
            j3
            j4
            j5
        
	    'lqc2 @lambda, 0(%0)
	    'lqc2 @j0, 0x00(%1)
	    'lqc2 @j1, 0x10(%1)
	    'lqc2 @j2, 0x20(%1)
	    'lqc2 @j3, 0x30(%1)
	    'lqc2 @j4, 0x40(%1)
	    'lqc2 @j5, 0x50(%1)
	    'lqc2 @force, 0x10(%2)
	    'lqc2 @torque, 0x20(%2)
        
            t0
            t1
            t2
            t3
            t4
            t5

            t0 = lambda * j0
            t1 = lambda * j1
            t2 = lambda * j2
            t3 = lambda * j3
            t4 = lambda * j4
            t5 = lambda * j5

            ~j0
            ~j1
            ~j2
            ~j3
            ~j4
            ~j5

            t0.x = t0.x + t0.y
            t0.z = t0.z + t0.w
            t1.x = t1.x + t1.y
            t1.z = t1.z + t1.w
            t2.x = t2.x + t2.y
            t2.z = t2.z + t2.w
            t3.x = t3.x + t3.y
            t3.z = t3.z + t3.w
            t4.x = t4.x + t4.y
            t4.z = t4.z + t4.w
            t5.x = t5.x + t5.y
            t5.z = t5.z + t5.w

            t0.x = t0.x + t0.z
            t1.x = t1.x + t1.z
            t2.x = t2.x + t2.z
            t3.x = t3.x + t3.z
            t4.x = t4.x + t4.z
            t5.x = t5.x + t5.z

            force.x = force.x + t0.x
            force.y = force.y + t1.x
            force.z = force.z + t2.x

            torque.x = torque.x + t3.x
            torque.y = torque.y + t4.x
            torque.z = torque.z + t5.x

            ~t0
            ~t1
            ~t2
            ~t3
            ~t4
            ~t5

	    'sqc2 @force, 0x10(%2)
	    'sqc2 @torque, 0x20(%2)

           ~force
           ~torque
           __end_expression_asm
           " : : "r" (L), "r" (jptr), "r" (&((bodyarray[bodyrefersto[num4rows*col+current4row]]).tag)));
        }
    }
    //**** point all fields of constraints structure to the constraints of the next partition
    oldJstore         +=18*size;    
    //Jpresent          +=3*m;
    Jbody             +=3*m;
    xi	              +=c4size;
    c	              +=c4size;
    lo	              +=c4size;
    hi	              +=c4size;
    slipfactor        +=c4size;
    xgamma            +=c4size;
    lambda            +=c4size;
    constraints.force +=24*m;
    Jsize             +=m;
    Jofs              +=m;
    
    keaPopPoolFrame();  
  } //End partition nonzero size test
  } //End partition loop
  
  //*** Print integrator input for debugging purposes
  
  #ifdef PRINT_INTEGRATOR_INPUT
  MdtKeaBody* b=(MdtKeaBody*)blist;
  printf("forces on bodies:\n");
  for(i=0;i!=num_bodies;i++)
  {
     for(k=0;k!=8;k++) printf("%12.6f ",b[i].force[k]); printf("\n");
     printf("%12.6f\n",b[i].invmass);
     printf("invIworld=\n");
     for(k=0;k!=4;k++) printf("%12.6f ",invIworld[i*12+4*0+k]);printf("\n");
     for(k=0;k!=4;k++) printf("%12.6f ",invIworld[i*12+4*1+k]);printf("\n");
     for(k=0;k!=4;k++) printf("%12.6f ",invIworld[i*12+4*2+k]);printf("\n");
  }
  #endif

  keaTic ("update vel,pos,rot");
  MeVector4 stepsizevec;
  stepsizevec[0] = parameters.stepsize;

  static MeVector4 oldConstantRegister __attribute__((aligned(16))) = {0.0f, 0.5f, -1.0f, 1.0f};
  static unsigned int sineconstants[4] __attribute__((aligned(16))) = { 0xbe2aaaa4, 0x3c08873e, 0xb94fb21f, 0x362e9c14 };

  MeVector4 debugvalues[8] __attribute__((aligned(16)));

  for (i=0, pb=(int *)blist, pt=(int *)tlist; i!=num_bodies; i++, pb+=*(pb+1)/4, pt+=sizeof(MdtKeaTransformation)/4)   
  {
    MdtKeaBody *b=(MdtKeaBody *)pb;
 
    //     __asm__ __volatile__("
    //     __expression_asm

    //         stepsize
    //         inversemass
    //         force
    //         invi0
    //         invi1
    //         invi2
    //         torque
    //         rotvel
    //         vel
    //         pos

    //         acceleration
    //         rotaccel
    //         temp3
    //         temp4
    //         temp5

    //         'lqc2  @stepsize,    0(%0)        
    //         'lqc2  @inversemass, 0(%4)
    //         'lqc2  @force,       0x10(%4)
    //         'lqc2  @torque,      0x20(%4)
    //         'lqc2  @invi0,       0x00(%5)
    //         'lqc2  @invi1,       0x10(%5)
    //         'lqc2  @invi2,       0x20(%5)
    //         'lqc2  @vel,         0x90(%4)
    //         'lqc2  @rotvel,      0xa0(%4)
    //         'lqc2  @pos,         0x30(%3)

    // # (1) calculate new velocity

    //         ACC = vel + K.x
    //         acceleration = force * inversemass.z
    //         ~force

    // 	# While waiting, calculate rotational acceleration

    //         temp3 = torque * invi0
    //         ~invi0
    //         temp4 = torque * invi1
    //         ~invi1
    //         temp5 = torque * invi2
    //         ~invi2
    //         vel = ACC + acceleration * stepsize.x

    // 	'sqc2  @acceleration,0xc0(%4)       # should be put in a nicer interleaved place (RT)

    // 	~torque
    //         ~acceleration

    // # (2) Then, calculate new rotational velocity [No dependency on previous calc]

    //         rotaccel.x = temp3.x    + temp3.y
    //         rotaccel.x = rotaccel.x + temp3.z
    // ~temp3
    //         rotaccel.y = temp4.y    + temp4.x
    //         rotaccel.y = rotaccel.y + temp4.z
    // ~temp4
    //         rotaccel.z = temp5.z    + temp5.x
    //         rotaccel.z = rotaccel.z + temp5.y
    // ~temp5
    //         ACC = rotvel + K.x

    // # More interleaving
    //         'sqc2 @vel, 0x90(%4)

    //         quat
    //         oldconst

    // 	'lqc2  @quat, 0xb0(%4)		# Load the quaternion - qrot
    //         'lqc2  @oldconst, 0x00(%2)      # Load the old style (EB2000) constant register

    //         rotvel = ACC + rotaccel * stepsize.x

    // 	'sqc2  @rotaccel,0xd0(%4)       # should be put in a nicer interleaved place (RT)

    // 	~rotaccel

    // # (3) Finally, update the position [Depends on (1)]

    //         ACC = pos + K.x
    //         'sqc2 @rotvel, 0xa0(%4)
    //         pos.xyz = ACC + vel * stepsize.x

    // # At this point: Add <<dodgy hack>> for fast-spinning objects.....
    // # Also, another <<dodgy hack>> to change quat representation by wfgg.
    // newstylequat
    // # This latter <<dodgy hack>> will be bubbled out after GDC I suppose.

    //     #'sqc2 @quat,0x00(%8)

    //     #    if (b->fastSpin)  (This is not likely in general case, in my opinion)
    //     'lw $8, 0x00(%6)
    //     ' beql $8, $0, 0f

    //     # rot = myw1*fastSpinAxis1 + myw2*fastSpinAxis2 + myw3*fastSpinAxis3
    //     rot
    //     fastSpinAxis

    //     'lqc2 @fastSpinAxis, 0x00(%7)
    //     'vmr32 @newstylequat, @quat
    //     #'vmr32 @newstylequat, @newstylequat
    //     #'vmr32 @newstylequat, @newstylequat

    //     rot = rotvel * fastSpinAxis
    //     rot.x = rot.x + rot.y
    //     rot.x = rot.x + rot.z

    //     #      keaDoFiniteRotation (b->qrot,b->fastSpinAxis,rot * stepsize);

    //     #void keaDoFiniteRotation (MeReal q[4], MeReal w[3], MeReal h)
    //     h
    //     # Means .....
    //     #  MeReal tmp[3],nw[3];
    //     tmp
    //     nw

    //     h.x = rot.x * stepsize.x

    //     #  MeReal wlen = MeSqrt (w[0]*w[0] + w[1]*w[1] + w[2]*w[2]);
    //     wlen
    //     wlen = fastSpinAxis * fastSpinAxis
    //     wlen.x = wlen.x + wlen.y
    //     wlen.x = wlen.x + wlen.z

    //     Q = | wlen.x
    //     'vwaitq
    //     wlen.x = K.x + Q

    //     #  MeReal wlen1 = MeRecip (wlen);
    //     Q = K.w /  wlen.x
    //     'vwaitq
    //     wlen1
    //     wlen1.x = K.x + Q

    //     #  for (i=0; i<3; i++) nw[i] = w[i]*wlen1;
    //     nw.xyz = fastSpinAxis.xyz * wlen1.x
    //     ~wlen1

    //     #  MeReal s = MeSin(wlen * h * APPEND_F(0.5));
    //     # <lemming>Oh No!</lemming>
    //     X
    //     S
    //     # SET UP NUMBERS AS PER SONY MANUAL
    //     'lqc2 @S, 0x00(%1)
    //     t1
    //     t2
    //     t3
    //     t4
    //     s

    //     X.x = h.x * wlen.x
    //     ~h
    //     ~wlen

    //     X.x = X.x * oldconst.y

    //     #'sqc2 @X, 0x00(%8)

    //     # 23 cycle sine starts here.
    //     t1.x = X * X
    //     ACC.xyzw = K + K.w


    //     t2.x = t1 * t1
    //     ACC.x = ACC.x + t1.x * S.x


    //     t3.x = t2 * t1
    //     ~t1
    //     t4.x = t2 * t2
    //     ACC.x = ACC.x + t2.x * S.y
    //     ~t2
    //     ACC.x = ACC.x + t3.x * S.z
    //     ~t3
    //     ACC.x = ACC.x + t4.x * S.w
    //     ~t4
    //     ~S
    //     s.x = ACC.x + K.x * K.x



    //     s.x = s.x * X.x
    //     ~X


    //     #'sqc2 @s, 0x00(%8)
    //     # s ready
    //     #  MeReal c = MeCos(wlen * h * APPEND_F(0.5));
    //     c
    //     c.x = s.x * s.x



    //     c.w = K.w - c.x



    //     Q = | c.w


    //     #'sqc2 @nw,0x00(%8)

    //     #  MeReal newq0 = q[0]*c - keaDot (q+1,nw)*s;
    //     newq
    //     dot
    //     dot.xyz = newstylequat * nw



    //     dot.xyz = dot.xyz * s.x



    //     dot.x = dot.x + dot.y



    //     dot.x = dot.x + dot.z
    //     'vwaitq
    //     c.x = K.x + Q
    //     #'sqc2 @c, 0x10(%8)
    //     newq.w = newstylequat.w * c.x
    //     newq.w = newq.w - dot.x

    //     #'sqc2 @newq,0x00(%8)
    //     ~dot

    //     #  keaCross (q+1,nw,tmp);

    //     'vopmula ACC, @newstylequat, @nw
    //     'vopmsub @tmp, @nw, @newstylequat
    //     'sqc2 @tmp,0x00(%8)
    //     q0nw
    //     q0nw.xyz = nw.xyz * newstylequat.w
    //     ~nw
    //     #  for (i=0; i<3; i++) q[i+1] = q[0]*s*nw[i] + c*q[i+1] - s*tmp[i];

    //     tmp.xyz = q0nw - tmp
    //     ~q0nw


    //     ACC.xyz = tmp.xyz * s.x
    //     ~tmp
    //     ~s
    //     newstylequat.xyz = ACC.xyz + newstylequat.xyz * c.x
    //     ~c

    //     #  q[0] = newq0;
    //     newstylequat.w = newq.w + K.x
    //     ~newq

    //     #      for (k=0; k<3; k++) myw[k] -= b->fastSpinAxis[k] * rot;
    //     fastSpinAxis.xyz = fastSpinAxis * rot.x
    //     ~rot


    //     rotvel = rotvel - fastSpinAxis        #note, rotvel equals the thing called myw in russells code
    //                                           #doesnt matter because rotvel is not stored back to memory
    //     #'sqc2 @rotvel,0x00(%8)
    //     ~fastSpinAxis

    //     # Please sir, can I have my quaternion representation back?
    //     'vmr32 @newstylequat, @newstylequat
    //     'vmr32 @newstylequat, @newstylequat
    //     'vmr32 @quat, @newstylequat
    //     ~newstylequat

    //     '0:
    //     #'sqc2 @quat,0x00(%8)
    // ###################################################################################################

    // # Register allocation now carried out by eac ...
    //  # Register allocation:		vf01 -> temp, quat''
    //  #			vf02 -> quat
    //  #			vf03 -> quat'
    //  #			vf04 -> quat''
    //  #			vf05 -> qmul
    //  #			vf06 -> qmul'
    //  #			vf07 -> qmul''
    //  #			vf08 -> ans
    //  #			vf09 -> ans'
    //  #			vf10 -> ans''
    //  #			the rest are temps :j

    // #'                                lqc2		vf30, 0xa0(%4)		# Load W ... - rotvel

    // # **Create dq** (vf31) from q(vf02) and W(@rotvel) ... col1-3 are vf27-9

    // temp1
    // temp2
    // temp3
    // temp4
    // temp5

    // '                                vmulx.xyzw	@temp1, @quat, @rotvel		# make the three 'column vectors' (! :)
    // '                                vmuly.xyzw	@temp2, @quat, @rotvel
    // 	pos.w = K.w + K.x
    // '                                vmulz.xyzw	@temp3, @quat, @rotvel

    // '                                sqc2           @pos,   0x30(%3)                  # store the position
    // '                                vaddw.z	@temp4, @temp2, @temp3
    // '                                vaddx.w	@temp4, @temp2, @temp1
    // '                                vaddy.x	@temp4, @temp2, @temp3
    // '                                vsubz.y	@temp4, @temp2, @temp1
    //                                  # first round complete
    // ~temp2

    // '                                vaddz.y	@temp5, @temp1, @temp4
    // '                                vsubw.z	@temp5, @temp3, @temp4
    // '                                vsubx.w	@temp5, @temp1, @temp4
    // ~temp1
    // '                                vsuby.x	@temp5, @temp3, @temp4
    //                                  # results ready
    // ~temp4
    // temp1
    // '                                vmr32.xyzw	@temp1, @temp5

    // ~temp5
    // #'                                 lqc2		@temp2, 0x00(%0)	       	# Get stepsize into @temp2x
    // '                                 vmuly.xyzw	@temp1, @temp1, @oldconst		# multiply by 0.5f
    // '                                 vaddax.xyzw	ACC, @quat, @K		# Make a copy of the quaternion in the accumulator
    // '                                 vmulz.xyz	@temp1, @temp1, @oldconst		# multiply by -1
    // '                                 vmaddx.xyzw	@quat, @temp1, @stepsize		# Maaaaarvellous.
    // ~stepsize
    // # Quaternion has been made

    // # Normalize Quaternion
    // temp2
    // '                                 vmul.xyzw	@temp2, @quat, @quat		# Square quaternion into temp
    // '                                 vaddy.x	@temp1, @temp2, @temp2		# 
    // '                                 vaddw.z	@temp1, @temp2, @temp2
    // '                                 vaddz.x	@temp1, @temp1, @temp1

    //     #################################=-+-=@(OLD HARDWARE)@=-
    //    #                                vsqrt	Q, @temp1x
    //   #                                vwaitq
    //  #                                vaddq.x	@temp1, vf00, Q
    //   #                                vdiv	Q, vf00w, @temp1x
    //    #                                vwaitq
    //     #################################

    // #'                                vrsqrt	Q, @K.w, @temp1.x		# Doesn't work on EB-1000 !!! (?)

    // Q = K.w / | temp1.x
    // r0
    // r1
    // r2
    // r1.w = K.w * K.x
    // r2.w = K.w * K.x

    //  '                                vwaitq				# .....

    // '                                vmulq.xyzw	@quat, @quat, Q		# Normalized quaternion is now in @quat

    //  # Quaternion -> 3x3 rotation matrix
    // # FIXME: What is this in terms of cross products i.e. can I make it a loit faster using the special 'outer product' instructions?
    // # Note that this requires a change to the quaternion representation which requires a serious heads-up.
    // temp4
    // qmul
    // quati
    // temp5
    // qmulii
    // qmuli
    // '                                vmr32.xyzw	@temp4, @quat			# rotation 1 into temp
    // '                                vmul.xyzw	@qmul, @quat, @quat		# ##### qmul is now ready #####
    // '                                sqc2	        @quat, 0xb0(%4)		        # Normalized Quaternion is now stored again.
    // '                                vadd.xyzw	@quat, @quat, @quat		# quat has now been doubled, which it needs to be to calculate qmul' and qmul''
    // '                                vmove.w	@quati, @temp4			
    // '                                vmr32.xyzw	@temp4, @temp4			# second rotation, keep in temp
    // '                                vmove.xy	@quati, @temp4
    // '                                vmr32.xyzw	@temp4, @temp4			# third rotation straight into destination quat''
    // '                                vmr32.xyzw	@temp5, @qmul			# Create a single rotation of qmul (##### qmul''' ready #####) to speed up addition.
    // '                                vmove.z	@quati, @temp4			# quat' ready
    // '                                vmul.xyzw	@qmulii, @quat, @temp4		# Might as well get ##### qmul'' ready ##### here
    // '                                vmul.xyzw	@qmuli, @quati, @quat		# ##### qmul' ready #####

    // ~quat
    // ~quati
    // temp6
    // temp7
    // '                                vadd.xyzw	@temp6, @qmul, @temp5
    // '                                vsub.xyzw	@temp7, @temp5, @qmul		# part way to R[0], R[4], and R[8]		
    // ~qmul
    // ~temp5

    // '                                vsuby.w	@temp2, @qmulii, @qmulii		# rightshift twice to get correct alignment	R[7]
    // '                                vaddw.y	@temp2, @qmulii, @qmulii		# rightshift thrice to get correct alignment	R[5]
    // '                                vsubx.y	@temp1, @qmuli, @qmuli		# rightshift thrice to get correct alignment	R[2]
    // '                                vaddz.w	@temp1, @qmuli, @qmuli		# rightshift twice to get correct alignment	R[1]
    // '                                vaddy.x	@r2, @qmuli, @qmuli		# R[6] complete
    // '                                vsubw.z	@temp2, @qmuli, @qmuli		# rightshift twice to get correct alignment R[3]
    // '                                vsubz.x	@r0, @temp6, @temp6		# R[0] complete
    // '                                vsuby.w	@temp3, @temp6, @temp6		# rightshift once to get correct alignment	R[8]
    // '                                vaddw.y	@r1, @temp7, @temp7		# R[4] complete
    // ~temp7
    // '                                vmr32.xyzw	@temp1, @temp1			# one more for R[1], two for R[2]
    // '                                vmr32.xyzw	@temp2, @temp2			# one more for R[3,7] two for R[5]
    // '                                vmr32.z	@r2,    @temp3
    // ~temp3
    // '                                vmr32.yw	@r0,    @temp1			# R[1] complete, another for R[2]
    // '                                vmr32.xyzw	@temp2, @temp2			# R[3,7] aligned, one more for R[5]
    // '                                vmr32.z	@r0,    @r0			# R[2] (and top row) complete
    // r0.w = K.w * K.x
    // '                                vmove.y	@r2,    @temp2			# R[7] (and bottom row) complete
    // '                                vmove.x	@r1,    @temp2			# R[3] complete
    // '                                vmr32.z	@r1,    @temp2			# R[5] complete

    // '                                sqc2	        @r0, 0x00(%3)	 	# Top (last) row stored ...
    // '                                sqc2	        @r2, 0x20(%3)	       	# Store bottom row
    // '                                sqc2	        @r1, 0x10(%3)    	# Store middle row

    //     __end_expression_asm


    //    " : : "r" (&(stepsizevec)), "r" (&(sineconstants[0])), "r" (&oldConstantRegister[0]) , "r" (pt) , "r" (pb), "r" (&(invIworld[i * 12])), "r" (&(((MdtKeaBody *)pb)->fastSpin)) , "r" (&(((MdtKeaBody *)pb)->fastSpinAxis[0])), "r" (&(debugvalues[0][0])) : "$8" );


    __asm__ __volatile__("
    __expression_asm

        stepsize
        inversemass
        force
        invi0
        invi1
        invi2
        torque
        rotvel
        vel
        pos
        
        acceleration
        rotaccel
        temp3
        temp4
        temp5

        'lqc2  @vel,         0x90(%4)
        'lqc2  @force,       0x10(%4)
        'lqc2  @inversemass, 0(%4)
        'lqc2  @torque,      0x20(%4)
        'lqc2  @invi0,       0x00(%5)
        'lqc2  @invi1,       0x10(%5)
        'lqc2  @invi2,       0x20(%5)
        'lqc2  @stepsize,    0(%0)        
        'lqc2  @rotvel,      0xa0(%4)
        'lqc2  @pos,         0x30(%3)
        
        # (1) calculate new velocity

        ACC = vel + K.x
        acceleration = force * inversemass.z
        ~force
         
        # While waiting, start to calculate rotational acceleration
	
        temp3 = torque * invi0
        temp4 = torque * invi1
        temp5 = torque * invi2
        vel = ACC + acceleration * stepsize.x        
	
        ~invi0
        ~invi1
        ~invi2
        ~torque


        # (2) Then, calculate new rotational velocity [No dependency on previous calc]
        
        rotaccel.x = temp3.x    + temp3.y
        rotaccel.y = temp4.y    + temp4.x
        rotaccel.z = temp5.z    + temp5.x
        'sqc2  @acceleration,0xc0(%4) # stall cycle in rotaccel calc.
        rotaccel.x = rotaccel.x + temp3.z
        rotaccel.y = rotaccel.y + temp4.z
        rotaccel.z = rotaccel.z + temp5.y
        ACC = rotvel + K.x
~temp3
~temp4
~temp5
~acceleration
 
        quat
        oldconst
	
        'lqc2  @quat, 0xb0(%4)	   # Load the quaternion - qrot
        'lqc2  @oldconst, 0x00(%2)      # Load the old style (EB2000) constant register

        rotvel = ACC + rotaccel * stepsize.x
        
        # (3) Update the position [Depends on (1)]
        
         ACC = pos + K.x
         pos.xyz = ACC + vel * stepsize.x

        # At this point: Add <<dodgy hack>> (seems reasonable though) for fast-spinning objects
        # Also, another <<dodgy hack>> to change quat representation by wfgg.
newstylequat
        # This latter <<dodgy hack>> will be bubbled out after GDC I suppose.

        #    if (b->fastSpin)  (This is not likely in general case)
        'lw $8, 0x00(%6)

        'sqc2 @vel, 0x90(%4) #while waiting for load
        'sqc2 @rotvel, 0xa0(%4)
        'sqc2 @rotaccel, 0xd0(%4)
        ~rotaccel

        'beql $8, $0, 0f

        # 'Reference' implementation in keaMathStuff.cpp
        # keaDoFiniteRotation is the original function's name

#######
        rot
        fastSpinAxis
        wlen
        h
        tmp
        nw
        S
        wlen1
        X
        t1
#######

        'lqc2 @fastSpinAxis, 0x00(%7)
        'vmr32 @newstylequat, @quat
        'lqc2 @S, 0x00(%1)
        rot = rotvel * fastSpinAxis
        wlen = fastSpinAxis * fastSpinAxis
        ACC.xyzw = K + K.w

        rot.x = rot.x + rot.y
        wlen.x = wlen.x + wlen.y


        rot.x = rot.x + rot.z
        wlen.x = wlen.x + wlen.z


        h.x = rot.x * stepsize.x
        Q = | wlen.x






        'vwaitq
        wlen.x = K.x + Q



        Q = K.w /  wlen.x
        X.x = h.x * wlen.x



        X.x = X.x * oldconst.y

        'vwaitq
        wlen1.x = K.x + Q
        t1.x = X * X


        nw.xyz = fastSpinAxis.xyz * wlen1.x
# 
######
        ~h
        ~wlen
        ~wlen1
        t2
        t3
        t4
        s
        q0nw
######
#
        t2.x = t1 * t1
        ACC.x = ACC.x + t1.x * S.x
        q0nw.xyz = nw.xyz * newstylequat.w
        fastSpinAxis.xyz = fastSpinAxis * rot.x
        t3.x = t2 * t1
        t4.x = t2 * t2
        ACC.x = ACC.x + t2.x * S.y
        rotvel = rotvel - fastSpinAxis
        ACC.x = ACC.x + t3.x * S.z
        ACC.x = ACC.x + t4.x * S.w
        s.x = ACC.x + K.x * K.x
        'vopmula ACC, @newstylequat, @nw


        s.x = s.x * X.x
#
######
        ~X
        ~t1
        ~t2
        ~t3
        ~t4
        ~S
        c
        newq
        dot
 ######
#
        'vopmsub @tmp, @nw, @newstylequat


        c.x = s.x * s.x
        tmp.xyz = q0nw - tmp


        c.w = K.w - c.x
        ACC.xyz = tmp.xyz * s.x


        Q = | c.w
        dot.xyz = newstylequat * nw



        dot.xyz = dot.xyz * s.x



        dot.x = dot.x + dot.y


        'vwaitq
        dot.x = dot.x + dot.z
        c.x = K.x + Q



        newq.w = newstylequat.w * c.x
        newstylequat.xyz = ACC.xyz + newstylequat.xyz * c.x


        newq.w = newq.w - dot.x
#    
######
        ~dot
        ~nw
        ~q0nw
        ~tmp
        ~s
        ~c
######
#



        newstylequat.w = newq.w + K.x



        'vmr32 @newstylequat, @newstylequat
        'vmr32 @newstylequat, @newstylequat
        'vmr32 @quat, @newstylequat
#
######
        ~newq
        ~rot
        ~fastSpinAxis
        ~newstylequat
######
#
        '0:
###################################################################################################

# Register allocation now carried out by eac ...
# Register allocation:		vf01 -> temp, quat''
#			vf02 -> quat
#			vf03 -> quat'
#			vf04 -> quat''
#			vf05 -> qmul
#			vf06 -> qmul'
#			vf07 -> qmul''
#			vf08 -> ans
#			vf09 -> ans'
#			vf10 -> ans''
#			the rest are temps :j

# **Create dq** (vf31) from q(vf02) and W(@rotvel) ... col1-3 are vf27-9

        temp1
        temp2
        temp3
        temp4
        temp5

        pos.w = K.w + K.x
        temp3 = quat * rotvel.z
        temp2 = quat * rotvel.y
        temp1 = quat * rotvel.x
        'sqc2 @pos, 0x30(%3)

        temp4.z = temp2.z + temp3.w
        temp4.w = temp2.w + temp1.x
        temp4.x = temp2.x + temp3.y
        temp4.y = temp2.y - temp1.z



        temp5.y = temp1.y + temp4.z
        temp5.z = temp3.z - temp4.w
        temp5.w = temp1.w - temp4.x

        temp5.x = temp3.x - temp4.y



        'vmr32.xyzw @temp1, @temp5


        ACC = quat + K.x
        temp1 = temp1 * oldconst.y



        temp1.xyz = temp1.xyz * oldconst.z



        quat = ACC + temp1 * stepsize.x





        temp2 = quat * quat



        temp1.x = temp2.x + temp2.y
        temp1.z = temp2.z + temp2.w



        temp1.x = temp1.x + temp1.z

        Q = K.w / | temp1.x






        'vwaitq

        quat = quat * Q

        ###########

        q
        # to new q-rep
        'vmr32 @q, @quat
        'sqc2 @quat, 0xb0(%4)		        # Normalized Quaternion is now stored again.
        #start dilip's qtor
        ~quat
        q2minqv2
        twoq
        twoq0qv
        v0
        v1
        v2
        m0
        m1
        m2
        one
#
#####
        v2 = K - K   
        m0 = K - K
        twoq = q + q
        m1 = K - K
        one = v2 + K.w
        v2.z = v2 + K.w
        ACC = twoq * q
        q2minqv2.w = ACC - K * K.w
        twoq0qv = q * twoq.w
        m2 = K - K
        'vmr32 @v1, @v2 
        'vopmula ACC, @twoq0qv, @v2
        ACC = ACC + q * twoq.z 
        ACC.z = ACC + one * q2minqv2.w
        'vopmsub @m2, @v2, @twoq0qv
        'vmr32 @v0, @v1
        'vopmula ACC, @twoq0qv, @v1
        ACC = ACC + q * twoq.y 
        ACC.y = ACC + one * q2minqv2.w
        'vopmsub @m1, @v1, @twoq0qv
        'vopmula ACC, @twoq0qv, @v0
        ACC = ACC + q * twoq.x 
        ACC.x = ACC + one * q2minqv2.w
        'vopmsub @m0, @v0, @twoq0qv
        'sqc2 @m2, 0x20(%3)
        'sqc2 @m1, 0x10(%3)
        #
        'sqc2 @m0, 0x0(%3)
        ##### 30 cycles! I should have rtfm
        #
        ~q2minqv2
        ~twoq
        ~twoq0qv
        ~v0
        ~v1
        ~v2
        ~m0
        ~m1
        ~m2
        ~one
        ~q
    __end_expression_asm
    " : : "r" (&(stepsizevec)), "r" (&(sineconstants[0])), "r" (&oldConstantRegister[0]) , "r" (pt) , "r" (pb), "r" (&(invIworld[i * 12])), "r" (&(((MdtKeaBody *)pb)->fastSpin)) , "r" (&(((MdtKeaBody *)pb)->fastSpinAxis[0])), "r" (&(debugvalues[0][0])) : "$8" );
  }; 
 
  //*** Print output data for debugging purposes

  #ifdef PRINT_KEA_OUTPUT
  MdtKeaBody*           b=(MdtKeaBody*)blist;
  MdtKeaTransformation* t=(MdtKeaTransformation*)tlist;
  for(i=0;i!=num_bodies;i++)
  {
    printf("force= ");for(k=0;k!=8;k++) printf("%12.6f ",b[i].force[k]);printf("\n");
    printf("transformation=\n");
    for(k=0;k!=4;k++) printf("%12.6f ",t[i].R0[k]);printf("\n");
    for(k=0;k!=4;k++) printf("%12.6f ",t[i].R1[k]);printf("\n");
    for(k=0;k!=4;k++) printf("%12.6f ",t[i].R2[k]);printf("\n");
    for(k=0;k!=4;k++) printf("%12.6f ",t[i].pos[k]);printf("\n");
  }
  #endif
  
  keaTic ("end");
  keaEndTiming();
  keaPrintTimesLine();
}
